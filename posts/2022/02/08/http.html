<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
    <title>HTTP | RunHio 的博客 ｜ RunHio Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="个人博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.f77d8e52.css" as="style"><link rel="preload" href="/assets/js/app.70cbfe2c.js" as="script"><link rel="preload" href="/assets/js/6.1419a14d.js" as="script"><link rel="preload" href="/assets/js/30.6289061a.js" as="script"><link rel="prefetch" href="/assets/js/10.2e15052e.js"><link rel="prefetch" href="/assets/js/11.9760aa5a.js"><link rel="prefetch" href="/assets/js/12.5dd51cf0.js"><link rel="prefetch" href="/assets/js/13.9cea7209.js"><link rel="prefetch" href="/assets/js/14.a4892ffa.js"><link rel="prefetch" href="/assets/js/15.7e37fdbc.js"><link rel="prefetch" href="/assets/js/16.bfc00efe.js"><link rel="prefetch" href="/assets/js/17.42b751d4.js"><link rel="prefetch" href="/assets/js/18.7d94d9ca.js"><link rel="prefetch" href="/assets/js/19.5bf2dfa4.js"><link rel="prefetch" href="/assets/js/2.ffb60f29.js"><link rel="prefetch" href="/assets/js/20.76be16d6.js"><link rel="prefetch" href="/assets/js/21.d587942b.js"><link rel="prefetch" href="/assets/js/22.0c501fa3.js"><link rel="prefetch" href="/assets/js/23.23075f51.js"><link rel="prefetch" href="/assets/js/24.31b365c9.js"><link rel="prefetch" href="/assets/js/25.c0a22e47.js"><link rel="prefetch" href="/assets/js/26.eb0b9821.js"><link rel="prefetch" href="/assets/js/27.902f48f0.js"><link rel="prefetch" href="/assets/js/28.792bd15b.js"><link rel="prefetch" href="/assets/js/29.1fa1e936.js"><link rel="prefetch" href="/assets/js/3.95e33632.js"><link rel="prefetch" href="/assets/js/31.4caa844a.js"><link rel="prefetch" href="/assets/js/32.469025af.js"><link rel="prefetch" href="/assets/js/33.6c8ad3f6.js"><link rel="prefetch" href="/assets/js/34.a6b6bcf1.js"><link rel="prefetch" href="/assets/js/35.3975429e.js"><link rel="prefetch" href="/assets/js/36.87997eee.js"><link rel="prefetch" href="/assets/js/37.05db4cc6.js"><link rel="prefetch" href="/assets/js/38.8c5a7fbc.js"><link rel="prefetch" href="/assets/js/39.e0da8621.js"><link rel="prefetch" href="/assets/js/4.467972aa.js"><link rel="prefetch" href="/assets/js/40.647a3e55.js"><link rel="prefetch" href="/assets/js/41.98c93d10.js"><link rel="prefetch" href="/assets/js/5.963c915c.js"><link rel="prefetch" href="/assets/js/7.90b85d0e.js"><link rel="prefetch" href="/assets/js/8.2155397b.js"><link rel="prefetch" href="/assets/js/9.ac493e9a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f77d8e52.css">
    <meta id="referrer" name="referrer" content="never" />
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-7f2e4136><header class="header-container" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/post-bg.jpeg);" data-v-93921ff8 data-v-7f2e4136><nav class="navbar" style="position:absolute;opacity:1;transition:all 0.5s ease-in-out;" data-v-93921ff8><a href="/" class="navbar-link router-link-active">
    RunHio'Blog
  </a> <ul class="navbar-links"><li><a href="/" class="router-link-active">
        HOME
      </a></li><li><a href="/about/">
        ABOUT
      </a></li><li><a href="/tags/">
        TAGS
      </a></li></ul> <div id="nav-icon"><span></span><span></span><span></span></div></nav> <div class="header-title" data-v-93921ff8 data-v-93921ff8><h1 data-v-93921ff8>HTTP</h1> <p data-v-93921ff8></p></div></header> <div class="container" data-v-b3fda33c data-v-7f2e4136><main class="main" style="width:60%;" data-v-b3fda33c><div class="post" data-v-b3fda33c data-v-b3fda33c><article class="main-div"><div class="post-content content content__default"><h2 id="http"><a href="#http" class="header-anchor">#</a> Http</h2> <h3 id="http报文"><a href="#http报文" class="header-anchor">#</a> http报文</h3> <p>http报文结构具体如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>起始行 <span class="token operator">+</span> 头部 <span class="token operator">+</span> 空行 <span class="token operator">+</span> 实体
</code></pre></div><h4 id="起始行"><a href="#起始行" class="header-anchor">#</a> 起始行</h4> <p>对于请求报文而言，起始行类似下面这样</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">GET</span> <span class="token operator">/</span>home <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
</code></pre></div><p>也就是<strong>方法 + 路径+ http版本</strong></p> <p>对于响应报文来说，起始行一般长这样</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span>
</code></pre></div><p>由<strong>http版本 + 状态码 + 原因</strong>组成</p> <h4 id="头部"><a href="#头部" class="header-anchor">#</a> 头部</h4> <p>请求头和响应头中包含较多的字段，具体可查看:</p> <p>https://kb.cnblogs.com/page/92320/</p> <h4 id="空行"><a href="#空行" class="header-anchor">#</a> 空行</h4> <p>很重要，用来区分开<strong>头部</strong>和<strong>实体</strong></p> <p>如果在头部中间故意加一个空行，那么空行后面的内容都会被视作实体</p> <h4 id="实体"><a href="#实体" class="header-anchor">#</a> 实体</h4> <p>具体的数据，body部分。请求报文对应的是请求体，响应报文对应的是响应体</p> <h4 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h4> <p>请求</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22799595/1644202209503-b1e3b639-a82d-476e-aa08-ab833d166b97.png" alt="img"></p> <p>响应</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22799595/1644202228731-fd563fa2-e872-4274-94a3-739e4bad505a.png" alt="img"></p> <h3 id="请求方法"><a href="#请求方法" class="header-anchor">#</a> 请求方法</h3> <p><strong>http/1.1</strong>规定了以下请求方法，注意都是大写</p> <ul><li><p>GET：通常用来获取资源</p></li> <li><p>HEAD：获取资源的元信息</p></li> <li><p>POST：提交数据，即上传数据</p></li> <li><p>PUT：修改数据</p></li> <li><p>DELETE：删除资源（几乎用不到）</p></li> <li><p>CONNECT：建立连接隧道，用于代理服务器</p></li> <li><p>OPTIONS：列出可对资源实行的请求方法，一般浏览器用于跨域前的预请求，判断是否可以与服务端通信</p></li> <li><p>TRACE：追踪请求-响应的传输路径</p></li></ul> <h4 id="get和post的区别"><a href="#get和post的区别" class="header-anchor">#</a> GET和POST的区别</h4> <ol><li><strong>TCP层面</strong></li></ol> <ul><li><p>GET产生一个TCP数据包，对于GET方式的请求，浏览器会把http的header和data一并发送出去，服务器响应200</p></li> <li><p>POST产生两个TCP数据包，对于POST，浏览器会先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200</p></li> <li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次</p></li></ul> <ol><li><strong>HTTP规定</strong></li></ol> <ul><li><p>语义不同，GET是获取数据，POST是提交数据</p></li> <li><p>GET在浏览器回退是无害的，而POST是会再次提交数据</p></li> <li><p>缓存机制不同</p></li> <li><ul><li>GET请求会被浏览器主动<code>cache</code>，也就是主动缓存，而POST不会，除非手动设置</li> <li>GET请求参数会被完整地保留在浏览器历史记录里面，而POST中的参数不会被保留</li></ul></li> <li><ul><li>GET产生的URL地址可以被<code>Bookmark</code>，也就是进行书签收藏，有助于迅速查找，而POST不可以</li></ul></li> <li><p>编码方式不同</p></li> <li><ul><li>GET请求只能进行URL编码（application/x-www-form-urlencoded）</li> <li>POST支持多种编码方式（application/x-www-form-urlencoded或multipart/form-data）</li></ul></li> <li><p>GET参数通过URL传递，POST放在Request body中</p></li> <li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</p></li></ul> <ol><li><strong>浏览器层面</strong></li></ol> <ul><li>GET请求在URL中传送参数是有长度限制的，不同浏览器的限制大小不一样，而POST没有限制</li></ul> <h3 id="url和uri的区别"><a href="#url和uri的区别" class="header-anchor">#</a> URL和URI的区别</h3> <p><strong>统一资源标识符URI</strong>就是在某一规则下能把一个资源独一无二地标识出来。</p> <p>拿人做例子，一个人的身份证就是URI，因为通过身份证能让我们能且仅能缺点一个人。</p> <p><strong>统一资源定位符URL</strong>，比如说：</p> <p>动物住址协议://地球/中国/浙江省/杭州市/<a href="https://www.zhihu.com/search?q=%E8%A5%BF%E6%B9%96%E5%8C%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A154309494%7D" target="_blank" rel="noopener noreferrer">西湖区<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/某大学/14号宿舍楼/525号寝/张三.人</p> <p>这样的一个字符串同样也唯一确定了一个人，起到了URI的作用，所以<strong>URL是URI的子集</strong></p> <p>可以这样理解：URI不一定非得是通过号码去确定，URI是在<strong>某一规则</strong>下标识出一个资源的字符串，通过地址或者号码都是可行的规则，其中通过地址规则实现的URI就被称作URL，URL是URI的一种实现，就像三角形包含等边三角形一样</p> <h3 id="http状态码"><a href="#http状态码" class="header-anchor">#</a> HTTP状态码</h3> <h4 id="_1xx"><a href="#_1xx" class="header-anchor">#</a> 1xx</h4> <p>表示目前是协议处理的中间状态，还需要后续操作</p> <ul><li><p><strong>100</strong></p></li> <li><ul><li>表示目前为止一切正常，客户端应该继续请求，如果已完成请求则忽略</li></ul></li> <li><p><strong>101</strong></p></li> <li><ul><li>表示服务器应客户端升级协议的请求正在进行协议切换，如切换成websocket或http2.0</li></ul></li></ul> <h4 id="_2xx"><a href="#_2xx" class="header-anchor">#</a> 2xx</h4> <p>表示成功的状态</p> <ul><li><p><strong>200</strong></p></li> <li><ul><li>表示请求已经成功，默认情况下状态码为200的响应可以被缓存</li></ul></li> <li><p><strong>201</strong></p></li> <li><ul><li>表示请求已经被成功处理，并且创建了新的资源，新的资源在应答返回之前已经被创建</li></ul></li> <li><p><strong>204</strong></p></li> <li><ul><li>结果正确处理了，但是服务端没数据给客户端，即响应报文没有实体主体，一般用于服务器接受客户端消息，但不必回复内容的情况</li> <li>在PUT请求中进行资源更新，但不需要改变当前展示给用户的页面，那么返回<code>204 No Content</code>。如果创建了新资源，那么返回<code>201 Created</code>。如果页面需要更新以后的新资源，返回<code>200 OK</code></li></ul></li> <li><p><strong>206</strong></p></li> <li><ul><li><code>206 Partial Content</code>，表示部分内容，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求，响应报文中包含由<code>Content-Range</code>指定范围的实体内容。</li></ul></li></ul> <h4 id="_3xx"><a href="#_3xx" class="header-anchor">#</a> 3xx</h4> <p>重定向状态，资源位置发生变动，需要重新请求</p> <ul><li><p><strong>301&amp;302</strong></p></li> <li><ul><li>301表示永久重定向，说明请求的资源已经被移动到了由Location头部指定的url上，是固定的不会再改变，搜索引擎会根据该响应修正；而302表示的是临时重定向。</li> <li>比如网站从HTTP升级到了HTTPS，以前的站点不再用了，应当返回<code>301</code>，这个时候浏览器会默认做缓存优化，第二次访问的时候会自动访问重定向的那个地址，而如果只是暂时不可用，那么返回<code>302</code>即可，和<code>301</code>不同的是浏览器并不会做缓存</li></ul></li> <li><p><strong>303</strong></p></li> <li><ul><li>效果和302一样。但是他明确规定了浏览器要用GET方法去访问新提供的URI</li></ul></li> <li><p><strong>304</strong></p></li> <li><ul><li>该状态码和重定向没有关系，而是走缓存路线，该状态码意味着命中了协商缓存</li> <li>说明所请求的资源在客户端本地未修改，服务器无需再次传输请求的内容，客户端可以直接使用缓存的内容</li></ul></li> <li><p><strong>307</strong></p></li> <li><ul><li>临时重定向，类似302，区别在于能够确保请求方法和消息主体不会发生改变</li></ul></li> <li><p><strong>308</strong></p></li> <li><ul><li>永久重定向，类似301，区别在于能够确保请求方法和消息主体不会发生改变</li></ul></li></ul> <h4 id="_4xx"><a href="#_4xx" class="header-anchor">#</a> 4xx</h4> <p>请求报文有误</p> <ul><li><p><strong>400</strong></p></li> <li><ul><li>开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了，一般是请求参数格式错误</li></ul></li> <li><p><strong>401</strong></p></li> <li><ul><li>请求需要认证的资源，但还没有认证，需要在请求主体加应该请求头：Authentic，实际情况中比如是忘记带token</li></ul></li> <li><p><strong>403</strong></p></li> <li><ul><li>实际上并不是请求报文出错，而是服务器禁止访问，一般是因为权限不够</li></ul></li> <li><p><strong>404</strong></p></li> <li><ul><li>表面服务器上没有这个资源</li></ul></li> <li><p><strong>405</strong></p></li> <li><ul><li><code>405 Method Not Allowed</code>，表面服务器禁止了使用当前HTTP方法的请求，一般是请求方法错了</li></ul></li> <li><p><strong>406</strong></p></li> <li><ul><li><code>406 Not Acceptable</code>，表示服务器不支持Accept、Accept-Charset、Accept-Encoding、 Accept-Language header 所要求的</li></ul></li> <li><p><strong>408</strong></p></li> <li><ul><li><code>408 Request Timeout</code>服务器等待时间太长</li></ul></li> <li><p><strong>409</strong></p></li> <li><ul><li>请求发生了冲突</li> <li>冲突最有可能发生在对PUT请求的响应中，例如当上传文件的版本比服务器上已存在的要旧时，从而导致版本冲突，那么就可能收到409的响应</li></ul></li> <li><p><strong>410</strong></p></li> <li><ul><li>说明请求的内容在服务器上不存在，同时是永久性丢失，如果不清楚是否为永久性或临时性丢失，则应该使用404</li></ul></li> <li><p><strong>413</strong></p></li> <li><ul><li>表示<strong>请求主体</strong>的大小超过了服务器愿意或有能力处理的限度，服务器可能会关闭连接以防止客户端继续发送请求</li> <li>如果“超出限度”是暂时性的，服务器应该返回<code>Retry-After</code>首部字段，说明这是暂时性的，以及客户端可以在什么时间后重试</li></ul></li> <li><p><strong>414</strong></p></li> <li><ul><li>URI过长，表示客户端所请求的URI超过了服务器允许的范围</li></ul></li> <li><p><strong>431</strong></p></li> <li><ul><li>由于<strong>请求中的首部字段</strong>的值太大，服务器拒绝接受客户端的请求</li></ul></li></ul> <h4 id="_5xx"><a href="#_5xx" class="header-anchor">#</a> 5xx</h4> <ul><li><p><strong>500</strong></p></li> <li><ul><li>服务器内部发生错误，出了啥错我们也不知道</li></ul></li> <li><p><strong>501</strong></p></li> <li><ul><li>服务器不支持请求的功能，无法完成请求，表示method不被服务器支持，无法处理。这里要和<code>405 Method Not Allowed</code>区分，405是服务器本身支持这个请求方法，但是请求接口时却用了别的方法，例如应该用put却用了delete，就返回405</li></ul></li> <li><p><strong>502</strong></p></li> <li><ul><li>网关错误，服务器自身的正常的。</li></ul></li> <li><p><strong>503</strong></p></li> <li><ul><li>表示服务器尚未处于可以接受请求的状态，通常造成这种情况的原因是由于服务器停机维护或已超载。</li></ul></li> <li><p><strong>505</strong></p></li> <li><ul><li>服务器不支持请求的HTTP协议的版本</li></ul></li></ul> <h3 id="http如何处理大文件的传输"><a href="#http如何处理大文件的传输" class="header-anchor">#</a> HTTP如何处理大文件的传输</h3> <p>对于几百M甚至上G的大文件来说，如果要一口气全部传输过来显示是不现实的，会有大量的等待时间，严重影响用户体验。HTTP针对这一场景采取了<code>范围请求</code>的解决方案，允许客户端仅请求一个资源的一部分。</p> <h4 id="如何支持"><a href="#如何支持" class="header-anchor">#</a> 如何支持</h4> <p>服务器要支持**范围请求，**要加上这样一个响应头</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Accept<span class="token operator">-</span>Ranges<span class="token operator">:</span> none
</code></pre></div><h4 id="range字段"><a href="#range字段" class="header-anchor">#</a> Range字段</h4> <p>对于客户端而言，它需要指定请求哪一部分，通过<code>Range</code>这个请求头字段确定，格式为<code>bytes=x-y</code>。如0-499表示从开始到第499个字节。</p> <p>服务器收到请求后，如果越界了，则返回<code>416</code>错误码，否则读取响应的片段，返回<code>206</code>状态码。</p> <p><strong>举例</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 单段数据</span>
Range<span class="token operator">:</span> bytes<span class="token operator">=</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>
<span class="token comment">// 多段数据</span>
Range<span class="token operator">:</span> bytes<span class="token operator">=</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token operator">-</span><span class="token number">39</span>
</code></pre></div><p><strong>单段数据</strong></p> <p>单段数据的请求，返回的响应如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">206</span> Partial Content
Content<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">10</span>
Accept<span class="token operator">-</span>Ranges<span class="token operator">:</span> bytes
Content<span class="token operator">-</span>Range<span class="token operator">:</span> bytes <span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token operator">/</span><span class="token number">100</span>

i am xxxxx
</code></pre></div><p>0-9表示请求的返回，100表示资源的总大小</p> <p><strong>多段数据</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">206</span> Partial Content
Content<span class="token operator">-</span>Type<span class="token operator">:</span> multipart<span class="token operator">/</span>byteranges<span class="token punctuation">;</span> boundary<span class="token operator">=</span><span class="token number">00000010101</span>
Content<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">189</span>
Connection<span class="token operator">:</span> keep<span class="token operator">-</span>alive
Accept<span class="token operator">-</span>Ranges<span class="token operator">:</span> bytes


<span class="token operator">--</span><span class="token number">00000010101</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain
Content<span class="token operator">-</span>Range<span class="token operator">:</span> bytes <span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token operator">/</span><span class="token number">96</span>

i am xxxxx
<span class="token operator">--</span><span class="token number">00000010101</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain
Content<span class="token operator">-</span>Range<span class="token operator">:</span> bytes <span class="token number">30</span><span class="token operator">-</span><span class="token number">39</span><span class="token operator">/</span><span class="token number">96</span>

eex jspy e
<span class="token operator">--</span><span class="token number">00000010101</span><span class="token operator">--</span>
</code></pre></div><p>使用<code>boundary</code>进行分割，最后的分隔符会添加<code>--</code>表示结束</p> <h3 id="什么是持久连接"><a href="#什么是持久连接" class="header-anchor">#</a> 什么是持久连接</h3> <p><code>http1.0</code>协议采用的是“请求——应答”模式，当使用普通模式，每个请求/应答，客户都要与服务端建立一个连接，完成之后立即断开连接（http协议为无连接协议）</p> <p><code>http1.1</code>支持长连接，即请求头添加<code>Connection:Keep-Alive</code>，使用Keep-Alive模式建立一个<code>TCP</code>连接后使客户端到服务端的连接持续有效，可以发送多个请求，当出现对服务器的后续请求时，<code>Keep-Alive</code>功能能避免重新建立连接</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644225620358-39d3dfb8-86c5-4732-9fd1-ecf0cb2f1adc.webp" alt="img"></p> <h4 id="长连接优缺点"><a href="#长连接优缺点" class="header-anchor">#</a> 长连接优缺点</h4> <p><strong>优点</strong></p> <ul><li><p>减少CPU以及内存的使用，因为不需要经常建立和关闭连接</p></li> <li><p>支持管道化的请求以及响应模式</p></li> <li><p>减少网络堵塞，因为减少了TCP请求</p></li> <li><p>发生错误时，也可以在不关闭连接的情况下进行错误提示</p></li></ul> <p><strong>缺点</strong></p> <ul><li>一个长连接建立后，如果一直保持连接，会浪费服务器的资源，可以在服务端配置<code>keepalive_timeout</code>设置长连接超时时间</li> <li>可能造成队头阻塞</li></ul> <h3 id="什么是管道化"><a href="#什么是管道化" class="header-anchor">#</a> 什么是管道化</h3> <p><code>http1.1</code>在使用<code>长连接</code>的情况下，建立一个连接通信后，连接上消息的传递类似于</p> <p>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2</p> <p>管道化连接的消息就变成了类似这样</p> <p>请求1 -&gt; 请求2 -&gt; 响应1 -&gt; 响应2</p> <p>管道化是在同一个TCP连接里<strong>发一个请求后不必等其回来就可以继续发送请求出去</strong>，这样可以减少整体响应的时间，但是<strong>服务器还是会安装请求的顺序响应</strong>，如果有许多请求，而前面的请求响应比较慢，就会造成队头阻塞</p> <h3 id="http1-1如何解决http的队头阻塞问题"><a href="#http1-1如何解决http的队头阻塞问题" class="header-anchor">#</a> HTTP1.1如何解决HTTP的队头阻塞问题</h3> <h4 id="什么是队头阻塞"><a href="#什么是队头阻塞" class="header-anchor">#</a> 什么是队头阻塞</h4> <p>由于HTTP传输是基于<code>请求-应答</code>的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在了一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理，这就是著名的<strong>HTTP队头阻塞问题。</strong></p> <h4 id="并发连接"><a href="#并发连接" class="header-anchor">#</a> 并发连接</h4> <p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其他所有任务。现在浏览器的标准中Chrome可以同时支持6个并发连接。</p> <h4 id="域名分片"><a href="#域名分片" class="header-anchor">#</a> 域名分片</h4> <p>既然一个域名可以支持6个长连接，那么可以多分配几个域名。比如<code>content1.runhio.com``content2.runhio.com</code>。这样一个runhio域名下可以分出非常多的二级域名，它们都指向了同样的一台服务器，能够并发的长连接就更多了。</p> <h3 id="http代理"><a href="#http代理" class="header-anchor">#</a> HTTP代理</h3> <p>常见的代理有两种：<code>普通代理</code>，<code>隧道代理</code></p> <h4 id="普通代理-中间人代理"><a href="#普通代理-中间人代理" class="header-anchor">#</a> 普通代理（中间人代理）</h4> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644227445321-6120f43c-a4a5-41d8-8f9a-16defc8a6f77.webp" alt="img"></p> <p>如图，代理服务器就像一个中间人，帮两边传递信息。不过他可以在中间帮我们过滤、缓存、负载均衡等一些处理。</p> <p>实际场景中客户端和服务器之间可以有多个代理服务器</p> <h4 id="隧道代理"><a href="#隧道代理" class="header-anchor">#</a> 隧道代理</h4> <p>客户端通过<code>CONNECT</code>方法请求隧道代理创建一个可以到任意目标服务器和端口号的TCP连接，创建成功之后隧道代理只做请求和响应数据的转发，在中间不做任何处理</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644227557881-5e5b32a0-13cc-4b7b-832d-a2efcac852ea.webp" alt="img"></p> <p><code>https</code>服务是需要证书的，而代理服务器显然没有，所以浏览器和代理之间无法创建<code>TLS</code>，所以就有了隧道代理，它把浏览器的数据原样传统，实现了通过中间代理和服务端进行TLS握手，再进行数据加密传输。</p> <h4 id="代理服务器的好处"><a href="#代理服务器的好处" class="header-anchor">#</a> 代理服务器的好处</h4> <ul><li><p><strong>突破访问限制</strong>：如访问一些单位或集团的内部资源，或用国外代理服务器，也就是翻墙</p></li> <li><p><strong>安全性更高</strong>：上网者可以通过这种方式隐藏自己的IP</p></li> <li><p><strong>负载均衡</strong>：客户端请求先到代理服务器，而代理服务器后面有多少源服务器，IP是多少，客户端是不知道的。因此，代理服务器收到请求后，根据特定算法把请求分发给不同服务器，让各个源服务器负载尽量均衡</p></li> <li><p><strong>缓存代理</strong>：将内容缓存到代理服务器</p></li></ul> <h4 id="代理常见的请求头"><a href="#代理常见的请求头" class="header-anchor">#</a> 代理常见的请求头</h4> <p><strong>Via</strong></p> <p>代理服务器通过<code>Via</code>字段来记录自己的痕迹。举个例子，现在中间有两台代理服务器：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>客户端 <span class="token operator">-</span><span class="token operator">&gt;</span> 代理<span class="token number">1</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 代理<span class="token number">2</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 源服务器
</code></pre></div><p>在源服务器收到请求后，会在<code>请求头</code>拿到这个字段：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Via<span class="token operator">:</span> proxy_server1<span class="token punctuation">,</span> proxy_server2
</code></pre></div><p>而源服务器响应时，最终在客户端会拿到这样的<code>响应头</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Via<span class="token operator">:</span> proxy_server2<span class="token punctuation">,</span> proxy_server1
</code></pre></div><p><strong>X-Forwarded-For</strong></p> <p>记录客户端请求的来源IP，每经过一级代理，代理服务器都会把这次请求的来源IP追加进去</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">X</span><span class="token operator">-</span>Forwarded<span class="token operator">-</span>For<span class="token operator">:</span> client<span class="token punctuation">,</span>proxy1<span class="token punctuation">,</span>proxy2
</code></pre></div><p><strong>X-Real-IP</strong></p> <p>不管中间经过多少代理，这个字段始终记录的是客户端最初的IP</p> <p><strong>X-Forwarded-For的问题</strong></p> <p>这个字段意味着每经过一个不同的代理，这个字段的名字都要变，从<code>客户端</code>到<code>代理1</code>，这个字段是客户端的IP，从<code>代理1</code>到<code>代理2</code>又要改变这个字段。</p> <p>这就会产生两个问题：</p> <ul><li>代理必须解析HTTP请求头，然后修改，比直接转发数据性能下降</li> <li>HTTPS通信过程中原始报文不允许修改</li></ul> <h3 id="http缓存"><a href="#http缓存" class="header-anchor">#</a> HTTP缓存</h3> <p>就是将http请求获取的页面资源存储在本地，之后再加载直接从缓存中获取而不用请求服务器，从而响应更快。</p> <h4 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h4> <p>第一次请求时，服务器把资源的过期时间通过响应头中的<code>Expires</code>和<code>Cache-Control</code>两个字段告诉浏览器，之后再请求这个资源时，会判断有没有过期，没有过期就直接拿来用，不向服务器发起请求，这就是强缓存。</p> <p><strong>Expires</strong></p> <p>用来指定资源到期的时间，服务器响应时把它添加到响应头中：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>expires<span class="token operator">:</span> Wed<span class="token punctuation">,</span> <span class="token number">22</span> Nov <span class="token number">2021</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">41</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span>
</code></pre></div><p><strong>Cache-Control</strong></p> <p>指定资源过期的时间，如下表示这个请求正确返回的300s内，资料可以使用，否则过期</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>cache<span class="token operator">-</span>control<span class="token operator">:</span>max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">300</span>
</code></pre></div><p><strong>Expires和Cache-Control的区别</strong></p> <ul><li><p>Expires是<code>HTTP/1.0</code>中的，Cache-Control是<code>HTTP/1.1</code>中的</p></li> <li><p>Expires是为了兼容，在不支持<code>HTTP/1.0</code>情况下使用</p></li> <li><p>两者同时存在时，Cache-Control优先级高于Expires</p></li></ul> <p><strong>Cache-Control:no-cache</strong></p> <p><code>Cache-Control:no-cache</code>并不是代表着不缓存，而是意味着不走强缓存，直接和服务器进行请求一次，进行协商缓存。</p> <p><code>Cache-Control:no-store</code>才是代表着不缓存</p> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <p><strong>Last-Modified&amp;If-Modified-Since</strong></p> <p>在强缓存过期的情况下，我们希望的是在资源文件没有更新的情况下，即使过期了也不会重新获取资源，而是继续使用旧的资源，这个时候就需要走协商缓存。</p> <p>在第一次请求资源时，服务器除了会返回给浏览器上面说的过期时间，还会在响应头添加<code>Last-Modeified</code>字段，告诉浏览器该资源的最后修改时间</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>last<span class="token operator">-</span>modified<span class="token operator">:</span> Fri<span class="token punctuation">,</span> <span class="token number">27</span> Oct <span class="token number">2021</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">35</span><span class="token operator">:</span><span class="token number">57</span> <span class="token constant">GMT</span>
</code></pre></div><p>然后浏览器再次请求时就会把这个时间再通过另一个字段<code>If-Modified-Since</code>，发送给服务器</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token operator">-</span>modified<span class="token operator">-</span>since<span class="token operator">:</span> Fri<span class="token punctuation">,</span> <span class="token number">27</span> Oct <span class="token number">2021</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">35</span><span class="token operator">:</span><span class="token number">57</span> <span class="token constant">GMT</span>
</code></pre></div><p>服务器再把这两个字段的时间进行对比，如果一样则说明文件没有被更新，就返回状态码<code>304</code>和空的响应体，浏览器直接拿过期的资源继续使用。</p> <p><strong>缺点：</strong></p> <ul><li>如果服务器那边打开了资源文件，即使没有对文件进行修改，但还是会造成<code>Last-Modified</code>被修改，导致不能命中协商缓存</li> <li>如果资源有周期性的变化，如资源修改后在一个周期内又修改回原来的样子，我们认为这个周期前的缓存还是可以使用的，但<code>Last-Modified</code>不这么认为。</li></ul> <p><strong>ETag&amp;If-None-Match</strong></p> <p>为了解决上述问题，引出了<code>ETag</code>和<code>If-None-Match</code>。</p> <p>第一次请求资源时，服务器还会在响应头上返回<code>ETag</code>，这个字段表示的是当前资源文件的一个唯一标识，这个标识由文件内容生成，能精准地感应文件的变化，只要文件内容不同，<code>ETag</code>就会重新生成。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>etag<span class="token operator">:</span> <span class="token constant">W</span><span class="token operator">/</span><span class="token string">&quot;132489-1627839023000&quot;</span>
</code></pre></div><p>然后浏览器再次请求的时候就会把这个文件标识，再通过另一个字段<code>If-None-Match</code>，再发送给服务器</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token operator">-</span>none<span class="token operator">-</span>match<span class="token operator">:</span> <span class="token constant">W</span><span class="token operator">/</span><span class="token string">&quot;132489-1627839023000&quot;</span>
</code></pre></div><p>服务器会把两个字段的内容进行比对，如果一样，则说明文件内容并没有改变，那么就说明命中了协商缓存。</p> <p><strong>Last-Modified和ETag的区别</strong></p> <ul><li><p>ETag感知文件的精准度要高于Last-Modified</p></li> <li><p>同时使用时，服务器会以ETag优先</p></li> <li><p>Last-Modified的性能高于ETag，因为ETag生成过程中需要服务器付出额外开销，会影响服务器性能。</p></li></ul> <h4 id="强缓存和协商缓存的区别"><a href="#强缓存和协商缓存的区别" class="header-anchor">#</a> 强缓存和协商缓存的区别</h4> <ul><li>优先查找强缓存，没有命中再走协商缓存</li> <li>强缓存不发请求到服务器，有时候资源更新了浏览器还不知道，但是协商缓存会发请求给服务器去检查资源是否有变更</li></ul> <h3 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h3> <h4 id="http缺点"><a href="#http缺点" class="header-anchor">#</a> HTTP缺点</h4> <ol><li><p>不具备机密性，HTTP是明文传输的，数据有可能泄露</p></li> <li><p>不具备真实性，无法认证发送方的身份，有可能是伪造的</p></li> <li><p>不具备完整性，数据可能被中间人窃取然后篡改</p></li></ol> <h4 id="ssl-tls"><a href="#ssl-tls" class="header-anchor">#</a> SSL/TLS</h4> <p><code>HTTPS</code>是超文本传输安全协议，即<code>HTTP+SSL/TLS</code>.</p> <p>浏览器和服务器通信之前会先进行协商，选出它们都支持的<code>加密套件</code>，用来实现安全的通信。</p> <p>例如：<strong>RSA-PSK-AES128-GCM-SHA256，各算法用途如下图</strong></p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644235698990-a63ade74-4cee-40b2-b060-0fc2efa70c1d.webp" alt="img"></p> <h4 id="对称加密"><a href="#对称加密" class="header-anchor">#</a> 对称加密</h4> <p>所谓对称加密，就是加密和解密使用同一个密钥。</p> <ol><li><p>浏览器给服务器发送一个随机数<code>client-random</code>和一个支持加密的加密方法列表</p></li> <li><p>服务器给浏览器返回另一个随机数<code>server-random</code>和双方都支持的加密方法</p></li> <li><p>然后两者用加密方法将两个随机数混合生成密钥，这就是通信双方加解密的密钥</p></li></ol> <p>但是对称加密中，将随机数和加密方法直接传送给对方，过程可能会被窃取，别人就能成功解密拿到数据</p> <h4 id="不对称加密"><a href="#不对称加密" class="header-anchor">#</a> 不对称加密</h4> <p>就是一对密钥，有<code>公钥</code>和<code>私钥</code>，其中一个密钥加密后的数据，只能让另一个密钥进行解密。</p> <ol><li><p>浏览器给服务器发送一个随机数<code>client-random</code>和一个支持的加密方法列表</p></li> <li><p>服务器把另一个随机数<code>server-random</code>、<code>加密方法</code>、<code>公钥</code>传送给浏览器</p></li> <li><p>浏览器用公钥将两个随机数加密，生成密钥，这个密钥只能由<code>私钥</code>解密</p></li></ol> <p>由于公钥反推出私钥的过程，在现在计算机运算能力下是可以做到的，所以非对称密钥至少要2048位才能保证安全性，这就导致了每次通信都需要大计算量去加解密，性能比对称加密要差很多。</p> <h4 id="tls的加密"><a href="#tls的加密" class="header-anchor">#</a> TLS的加密</h4> <p>实际上，TLS用的是两种算法的混合加密。通过<strong>非对称加密算法</strong>交换<strong>对称加密算法</strong>的密钥，交换之后再全程使用<strong>对称加密</strong>进行数据传输。</p> <ol><li><p>浏览器给服务器发送一个随机数<code>client-random</code>和一个支持的加密方法列表</p></li> <li><p>服务器把另一个随机数<code>server-random</code>、<code>加密方法</code>、<code>公钥</code>传回给浏览器</p></li> <li><p>浏览器又生成另一个随机数<code>pre-random</code>，并用<code>公钥</code>加密后传输给服务器</p></li> <li><p>服务器用<code>私钥</code>解密，得到<code>pre-random</code></p></li> <li><p>浏览器和服务器都将三个随机数用加密方法混合生成最终密钥</p></li></ol> <p>这样即使被劫持了，中间人没有私钥就拿不到<code>pre-random</code>，就无法生成最终的密钥。</p> <h4 id="数字签名"><a href="#数字签名" class="header-anchor">#</a> 数字签名</h4> <p>假如在一开始我们就被劫持了，拿到的公钥是中间人的而不是服务器的，数据还是会被窃据，所以数字证书就来了。</p> <p><strong>数字证书（数字签名）</strong></p> <p>数字证书需要向有权威的<code>认证机构（CA）</code>获取授权给服务器。首先，<code>服务器</code>和<code>CA</code>机构分别有一对密钥（公钥和私钥），数字证书的生成过程：</p> <ul><li><p>CA机构通过摘要算法生成服务器公钥的<strong>摘要</strong></p></li> <li><p>CA机构通过<strong>CA私钥</strong>以及特定签名算法<strong>加密</strong>上述生成的摘要，生成签名</p></li> <li><p>把签名、服务器公钥打包放入<code>数字签名</code>，并返回给服务器</p></li></ul> <p>服务器配置好证书，以后客户端连接服务器，都先把证书发给客户端验证并获取服务器的公钥</p> <p><strong>证书验证流程</strong></p> <ul><li>使用<strong>CA公钥</strong>和声明的签名算法对CA中的签名进行**解密，**得到服务器的公钥的摘要内容</li> <li>再用摘要算法对证书里面的服务器公钥生成摘要，把这个摘要和上一步得到的摘要进行比对，如果一致则说明证书合法，里面的公钥也是正确的，就可以进行下一步通信</li></ul> <h4 id="https如何解决http的缺点"><a href="#https如何解决http的缺点" class="header-anchor">#</a> HTTPS如何解决HTTP的缺点</h4> <ol><li><strong>机密性</strong></li></ol> <p>信息的机密性HTTPS依靠对称加密和非对称加密来完成，具体参考上述流程</p> <ol><li><strong>完整性</strong></li></ol> <p>信息传输的途中，我们的信息很有可能被第三方进行劫持篡改，通用方法是使用散列算法如MD5将传输内容hash一次得到hash值，即**摘要。**客户端使用密钥对摘要和信息内容进行加密，然后传输给服务端，服务端解密获得原始内容和摘要值，这时服务端使用相同的hash算法对原始内容进行hash，然后把两个hash值进行比对，如果一致则说明信息没有被篡改</p> <ol><li><strong>真实性</strong></li></ol> <p>使用数字证书验证真实性，具体参考上述流程</p> <h4 id="http和https的区别"><a href="#http和https的区别" class="header-anchor">#</a> HTTP和HTTPS的区别</h4> <ul><li><p>HTTP是明文传输，不安全，HTTPS是加密传输的，安全的多</p></li> <li><p>HTTP端口号是80，HTTPS端口号是443</p></li> <li><p>HTTP不用证书，免费，HTTPS需要认证证书，要钱</p></li> <li><p>连接方式不同，HTTP三次握手，HTTPS中TLS1.2版本要7次，TLS1.3要6次</p></li> <li><p>HTTP在应用层，而HTTPS的TLS在传输层</p></li> <li><p>HTTP是无状态的，而HTTPS是有状态的，因为TLS这层需要服务器和客户端去缓存密钥，而不是每个请求都执行一次密钥交换</p></li></ul> <h4 id="https连接过程"><a href="#https连接过程" class="header-anchor">#</a> HTTPS连接过程</h4> <p>https比http多了一步TLS连接，TLS连接有以下方式</p> <p><strong>RSA握手</strong></p> <p>早期的TLS密钥交换法都是使用RSA算法，它的握手流程如下：</p> <ol><li><p>浏览器给服务器发送一个随机数<code>client-random</code>和一个支持的加密方法列表</p></li> <li><p>服务器把另一个随机数<code>server-random</code>、<code>加密方法</code>、<code>公钥</code>传给浏览器</p></li> <li><p>浏览器又生成另一个随机数<code>pre-random</code>，并用公钥加密后传给浏览器</p></li> <li><p>服务器再用私钥解密，得到<code>pre-random</code>，此时浏览器和服务器都得到了三个随机数，各自将三个随机数用加密方法混合生成最终密钥</p></li></ol> <p><strong>RSA弊端</strong></p> <p>但是如今RSA已经不适用了，因为一旦服务器的私钥泄露了，那么中间人可以通过私钥计算出之前所有报文的<code>secret</code>，破解之前的所有报文。</p> <p><strong>ECDHE握手</strong></p> <p>在<code>TLS1.2</code>版本用的是<code>ECDHE密钥交换法</code></p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644245590610-3ab4649d-12bf-47db-b0b1-07f9695fd25f.webp" alt="img"></p> <ol><li><p>浏览器给服务器发送一个随机数<code>client-random</code>，TLS版本和一个支持的加密方法列表</p></li> <li><p>服务器生成一个椭圆曲线参数<code>server-params</code>、随机数<code>server-random</code>、<code>加密方法</code>、<code>证书</code>给浏览器</p></li> <li><p>浏览器又生成椭圆曲线参数<code>client-params</code>，握手数据摘要等信息给服务器</p></li> <li><p>服务器和浏览器两边得到<code>server-params</code>和<code>client-params</code>后用ECDHE算法直接算出<code>pre-random</code>，两边都有三个随机数后，再将三个随机数加密混合生成最终密钥</p></li></ol> <p>中间椭圆曲线传递过程没有加密，如果被中间人截获了呢，为什么这样就比RSA安全呢？</p> <p>答案请看下图！中间传递是两个椭圆参数就是图中所说的<strong>公钥Q</strong></p> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22799595/1644246098591-00617ace-5fad-4a02-9080-28f1a9126e1f.png" alt="img"></p> <p>在<code>TLS1.3</code>版本中的握手变成了这样，简化了握手步骤</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644246164250-c44f817d-5cb6-489e-b362-d15814e04481.webp" alt="img"></p> <h3 id="http2"><a href="#http2" class="header-anchor">#</a> HTTP2</h3> <h4 id="二进制分帧层"><a href="#二进制分帧层" class="header-anchor">#</a> 二进制分帧层</h4> <p>HTTP2性能提升的核心在于二进制分帧层。HTTP2是用二进制协议，它采用二进制格式传输数据而不是1.x的文本格式。</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644249402541-41f7c584-12c8-4547-8fb2-1c44ebda1b63.webp" alt="img"></p> <p>原来的<code>Headers+Body</code>的报文格式如今被拆分成了一个个二进制的帧，用<strong>Header帧</strong>存放头部字段，用<strong>Data帧</strong>存放请求体字段。</p> <p>三个概念：</p> <ol><li><p>流Stream：已建立的TCP连接上的双向字节流，可以承载一个或多个消息</p></li> <li><p>消息Message：一个完整的HTTP请求或响应，由一个或多个帧组成，特定消息的帧在同一个流上发送，这就意味着一个HTTP请求或响应只能在一个流上发送</p></li> <li><p>帧Frame：通信的基本单位</p></li></ol> <p><strong>一个TCP连接上可以有任意数量的流</strong></p> <h4 id="多路复用"><a href="#多路复用" class="header-anchor">#</a> 多路复用</h4> <p>HTTP2完美解决了队头阻塞的问题。</p> <p>HTTP2让所有的通信都在一个TCP连接上完成，真正实现了请求的并发。HTTP2建立一个TCP连接，一个连接上可以有任意多个流，消息分割成一个或多个帧在各自的流里面传输，也就是一个请求一个流，这样就能同时发多个请求了。帧传输过去之后，再进行重组，形成一个完整的请求或响应，这使得所有的请求或响应都不会被阻塞</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644250073592-f74bbe3f-79f4-4811-a054-eecd01b475ff.webp" alt="img"></p> <h4 id="头部压缩"><a href="#头部压缩" class="header-anchor">#</a> 头部压缩</h4> <p>在1.x版本中，首部用文本格式传输，通常会给每个传输增加500-800字节的开销，而有些请求的一些首部字段都是相同的，例如cookie，user-agent等，HTTP2针对首部字段，采用了对应的压缩算法——HPACK。</p> <ul><li><p>维护一份相同的静态字典，包含常见的头部名称和值</p></li> <li><p>维护一份相同的动态字典，可以动态地添加内容</p></li> <li><p>通过静态Huffman编码对传输的首部字段进行编码</p></li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644250595469-5b1596db-d546-4adf-9fca-d2c6a8be4430.webp" alt="img"></p> <p>所以在传输首部字段时，例如要传递<code>method:GET</code>，那么只需要传递静态字典里面它对应的索引值就可以了，一个字节搞定。像user-agent、cookie这种静态字典里面只有首部名称而没有值的首部，第一次传输需要user-agent在静态字典中的索引以及他的值，值会采用Huffman编码来减少体积。</p> <p>第一次传输过user-agent之后，浏览器和服务器会把它添加到自己的动态字典中，后续传输只传对应的索引就好了。</p> <h4 id="服务器端推送"><a href="#服务器端推送" class="header-anchor">#</a> 服务器端推送</h4> <p>服务器端推送使得服务器可以预测客户端需要的资源，主动推送到客户端。</p> <p>例如：客户端请求index.html，服务器端能够额外推送<code>script.js</code>和<code>style.css</code>。实现原理就是客户端发出页面请求时，服务器端能够分析这个页面所依赖的其他资源，主动推送到客户端的缓存，当客户端收到原始页面的请求时，它需要的资源已经位于缓存。</p></div></article> <div class="main-div vssue"><!----></div></div></main> <aside class="aside" data-v-b3fda33c data-v-b3fda33c><div class="info-card main-div" data-v-1311ce9e data-v-b3fda33c><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/bg2.jpg);" data-v-1311ce9e><img src="/avatar-top.jpeg" alt="RunHio" class="info-avatar" data-v-1311ce9e></div> <div class="info-card-body" data-v-1311ce9e><section class="info-name" data-v-1311ce9e>
      RunHio
    </section> <section class="info-desc" data-v-1311ce9e>Record Growth</section> <section class="info-contact" data-v-1311ce9e><section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-location" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          Guangzhou, China
        </span></span></section> <!----> <section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-email" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          1056333479@qq.com
        </span></span></section></section></div> <div class="info-card-footer" data-v-1311ce9e><p class="footer-sns-link" data-v-1311ce9e><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-csdn" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-weibo" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-juejin" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-zhihu" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-github" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a></p></div></div> <div class="post-toc main-div aside-toc" style="position:relative;top:0;width:0px;" data-v-b3fda33c><h4>- CATALOG</h4> <div class="post-nav-toc"><ul><li><a href="/posts/2022/02/08/http.html#http">Http</a><ul><li><a href="/posts/2022/02/08/http.html#http报文">http报文</a></li><li><a href="/posts/2022/02/08/http.html#请求方法">请求方法</a></li><li><a href="/posts/2022/02/08/http.html#url和uri的区别">URL和URI的区别</a></li><li><a href="/posts/2022/02/08/http.html#http状态码">HTTP状态码</a></li><li><a href="/posts/2022/02/08/http.html#http如何处理大文件的传输">HTTP如何处理大文件的传输</a></li><li><a href="/posts/2022/02/08/http.html#什么是持久连接">什么是持久连接</a></li><li><a href="/posts/2022/02/08/http.html#什么是管道化">什么是管道化</a></li><li><a href="/posts/2022/02/08/http.html#http1-1如何解决http的队头阻塞问题">HTTP1.1如何解决HTTP的队头阻塞问题</a></li><li><a href="/posts/2022/02/08/http.html#http代理">HTTP代理</a></li><li><a href="/posts/2022/02/08/http.html#http缓存">HTTP缓存</a></li><li><a href="/posts/2022/02/08/http.html#https">HTTPS</a></li><li><a href="/posts/2022/02/08/http.html#http2">HTTP2</a></li></ul></li></ul></div></div></aside></div> <footer class="footer" data-v-7f2e4136><p class="footer-sns-link"><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-csdn"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-weibo"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-juejin"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-zhihu"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-github"></use></svg></span></a></p> <div class="copyright"><span id="custom">Copyright &copy; RunHio Blog 2021 <br /> </span> <!----></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.70cbfe2c.js" defer></script><script src="/assets/js/6.1419a14d.js" defer></script><script src="/assets/js/30.6289061a.js" defer></script>
  </body>
</html>