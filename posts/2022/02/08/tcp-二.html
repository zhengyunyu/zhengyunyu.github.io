<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
    <title>TCP(二) | RunHio 的博客 ｜ RunHio Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="个人博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.f77d8e52.css" as="style"><link rel="preload" href="/assets/js/app.70cbfe2c.js" as="script"><link rel="preload" href="/assets/js/6.1419a14d.js" as="script"><link rel="preload" href="/assets/js/16.bfc00efe.js" as="script"><link rel="prefetch" href="/assets/js/10.2e15052e.js"><link rel="prefetch" href="/assets/js/11.9760aa5a.js"><link rel="prefetch" href="/assets/js/12.5dd51cf0.js"><link rel="prefetch" href="/assets/js/13.9cea7209.js"><link rel="prefetch" href="/assets/js/14.a4892ffa.js"><link rel="prefetch" href="/assets/js/15.7e37fdbc.js"><link rel="prefetch" href="/assets/js/17.42b751d4.js"><link rel="prefetch" href="/assets/js/18.7d94d9ca.js"><link rel="prefetch" href="/assets/js/19.5bf2dfa4.js"><link rel="prefetch" href="/assets/js/2.ffb60f29.js"><link rel="prefetch" href="/assets/js/20.76be16d6.js"><link rel="prefetch" href="/assets/js/21.d587942b.js"><link rel="prefetch" href="/assets/js/22.0c501fa3.js"><link rel="prefetch" href="/assets/js/23.23075f51.js"><link rel="prefetch" href="/assets/js/24.31b365c9.js"><link rel="prefetch" href="/assets/js/25.c0a22e47.js"><link rel="prefetch" href="/assets/js/26.eb0b9821.js"><link rel="prefetch" href="/assets/js/27.902f48f0.js"><link rel="prefetch" href="/assets/js/28.792bd15b.js"><link rel="prefetch" href="/assets/js/29.1fa1e936.js"><link rel="prefetch" href="/assets/js/3.95e33632.js"><link rel="prefetch" href="/assets/js/30.6289061a.js"><link rel="prefetch" href="/assets/js/31.4caa844a.js"><link rel="prefetch" href="/assets/js/32.469025af.js"><link rel="prefetch" href="/assets/js/33.6c8ad3f6.js"><link rel="prefetch" href="/assets/js/34.a6b6bcf1.js"><link rel="prefetch" href="/assets/js/35.3975429e.js"><link rel="prefetch" href="/assets/js/36.87997eee.js"><link rel="prefetch" href="/assets/js/37.05db4cc6.js"><link rel="prefetch" href="/assets/js/38.8c5a7fbc.js"><link rel="prefetch" href="/assets/js/39.e0da8621.js"><link rel="prefetch" href="/assets/js/4.467972aa.js"><link rel="prefetch" href="/assets/js/40.647a3e55.js"><link rel="prefetch" href="/assets/js/41.98c93d10.js"><link rel="prefetch" href="/assets/js/5.963c915c.js"><link rel="prefetch" href="/assets/js/7.90b85d0e.js"><link rel="prefetch" href="/assets/js/8.2155397b.js"><link rel="prefetch" href="/assets/js/9.ac493e9a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f77d8e52.css">
    <meta id="referrer" name="referrer" content="never" />
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-7f2e4136><header class="header-container" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/post-bg.jpeg);" data-v-93921ff8 data-v-7f2e4136><nav class="navbar" style="position:absolute;opacity:1;transition:all 0.5s ease-in-out;" data-v-93921ff8><a href="/" class="navbar-link router-link-active">
    RunHio'Blog
  </a> <ul class="navbar-links"><li><a href="/" class="router-link-active">
        HOME
      </a></li><li><a href="/about/">
        ABOUT
      </a></li><li><a href="/tags/">
        TAGS
      </a></li></ul> <div id="nav-icon"><span></span><span></span><span></span></div></nav> <div class="header-title" data-v-93921ff8 data-v-93921ff8><h1 data-v-93921ff8>TCP(二)</h1> <p data-v-93921ff8></p></div></header> <div class="container" data-v-b3fda33c data-v-7f2e4136><main class="main" style="width:60%;" data-v-b3fda33c><div class="post" data-v-b3fda33c data-v-b3fda33c><article class="main-div"><div class="post-content content content__default"><h2 id="tcp如何实现可靠传输"><a href="#tcp如何实现可靠传输" class="header-anchor">#</a> TCP如何实现可靠传输</h2> <h3 id="重传机制"><a href="#重传机制" class="header-anchor">#</a> 重传机制</h3> <p>TCP实现可靠传输的方式之一，是提供序列号与确认应答。</p> <p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回应该确认应答消息，表示已收到消息。</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644324667505-dc69a86b-ef68-44bf-803b-57f77a102040.webp" alt="img"></p> <h4 id="超时重传"><a href="#超时重传" class="header-anchor">#</a> 超时重传</h4> <p>重传机制的其中一个方式，就是在发送数据数据时，设定一个定时器，当超过指定的时间后，没有收到对方的<code>ACK</code>确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p> <p><strong>重传的原因有</strong>：</p> <ul><li>数据丢失</li> <li>应答ACK丢失</li></ul> <p>TCP的超时重传策略是超时时间间隔加倍，当遇到一次重传的时候，超时时间就会加倍，当收到ACK时，则会重置超时时间</p> <h4 id="快速重传"><a href="#快速重传" class="header-anchor">#</a> 快速重传</h4> <p>快速重传的工作方式是当收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的报文段</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22799595/1644325455963-14350f33-8a6f-431c-ae0f-d9b189b7fbe8.png" alt="img"></p> <h4 id="sack"><a href="#sack" class="header-anchor">#</a> SACK</h4> <p>快速重传只解决了一个问题，就是超时时间的问题，但是重传的时候，是重传之前的一个，还是重传之前的所有。</p> <p><code>SACK</code>叫选择性确定，这种方式需要在TCP头部的选项字段中加一个<code>SACK</code>，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644325606389-d7b20fb4-935c-4e85-9484-8e8b585be946.webp" alt="img"></p> <p>如图，发送方收到了三次同样的ACK确认报文，于是就会触发快速重传机制，通过<code>SACK</code>信息发现只有<code>200-299</code>这段数据丢失，于是只重发这一段数据。</p> <p><strong>产生时机</strong></p> <ul><li>当接收方收到乱序的数据时就会回复SACK，正常顺序的就会回复ACK</li></ul> <h4 id="d-sack"><a href="#d-sack" class="header-anchor">#</a> D-SACK</h4> <p><code>D-SACK</code>是用来告诉发送方，有哪些数据被重复接收了。</p> <p><strong>例子：ACK丢失</strong></p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644325862323-16c8a1f3-5d78-4bb2-b5e9-129ba455a45c.webp" alt="img"></p> <ul><li><p>接收方发给发送方的两个ACK确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000-3499）</p></li> <li><p>于是接收方发现数据是重复收到的，回了一个<code>SACK=3000-3500</code>，告诉发送方3000-3500的数据已被接收</p></li> <li><p>这样发送方就知道数据没有丢，是接收方的ACK丢了</p></li></ul> <p><strong>例子：网络延时</strong></p> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644326467718-96717887-cd61-4c6b-85a9-17d61da38faa.webp" alt="img"></p> <ul><li><p>数据包（1000-1499）被网络延迟了，导致发送方没有收到ACK1500的确认报文</p></li> <li><p>触发了快速重传机制后，被延迟的数据包（1000-1499）又到了接收方</p></li> <li><p>所以接收方回了一个SACK=1000-1500，表示这是个重复的包</p></li> <li><p>于是发送方就知道快速重传触发的原因不是发出去的包丢了，也不是回应的ACK丢了，而是因为网络延迟</p></li></ul> <p>所以，D-SACK的好处：</p> <ol><li>可以让发送方知道，是发出去的包丢了，还是接收方回应的ACK包丢了</li> <li>可以知道是不是发送方的数据包被网络延迟了</li></ol> <h3 id="滑动窗口"><a href="#滑动窗口" class="header-anchor">#</a> 滑动窗口</h3> <p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区保留自己已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p> <h4 id="流水线"><a href="#流水线" class="header-anchor">#</a> 流水线</h4> <p><strong>发送方</strong></p> <ul><li>有一个窗口，TCP数据不是一个个发的，是每次发送多个</li></ul> <p><strong>接收方</strong></p> <ul><li>有一个窗口，数据不是一个个接收的，也可以接收很多个，可以接收乱序的数据</li></ul> <h4 id="序号和确认号机制"><a href="#序号和确认号机制" class="header-anchor">#</a> 序号和确认号机制</h4> <p>发送的数据是标上了序号的，而且发送方也是需要有接收方回复确认号来判断自己是否发送正常</p> <h4 id="累计确认"><a href="#累计确认" class="header-anchor">#</a> 累计确认</h4> <p>发送方不必一定要收到所有请求的ACK，收到某个ACK即可表明它前面的ACK都顺利到达发送方了</p> <h4 id="窗口"><a href="#窗口" class="header-anchor">#</a> 窗口</h4> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22799595/1644327332986-04423ea5-3803-4fa7-ab43-2f7a3382fc67.png" alt="img"></p> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22799595/1644327339197-75770de8-d653-42d7-a8aa-e2ee55f100fc.png" alt="img"></p> <h3 id="流量控制"><a href="#流量控制" class="header-anchor">#</a> 流量控制</h3> <p>发送方不能无脑地发数据给接收方，要考虑接收方处理能力。</p> <p>如果一直无脑发数据给对方，但对方处理不过来，那么就会导致触发重发机制，对网络流量造成浪费。</p> <p>所谓流量控制，就是TCP提供了一种机制可以让发送方根据接收方的实际接收能力，控制发送的数据量。</p> <h4 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h4> <p>利用TCP报文段中的首部字段——接收窗口来实现，这个接收窗口用于接收方发送给发送方，告诉发送方当前接收方还有多少可用的缓存空间</p> <h4 id="窗口收缩过程"><a href="#窗口收缩过程" class="header-anchor">#</a> 窗口收缩过程</h4> <p>TCP规定是不允许同时减少缓存同时收缩窗口的，或者先减少缓存再收缩窗口，</p> <h4 id="死锁"><a href="#死锁" class="header-anchor">#</a> 死锁</h4> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22799595/1644328789190-be690e78-7a64-42e4-82f1-7e55e8476ad3.png" alt="img"></p> <ol><li>当接收方通知发送方窗口为0后，发送方就不会继续发送数据了，当接收方处理好数据后，窗口增大了，会通知发送方窗口变大的消息</li> <li>会向发送方通告一个窗口非0的ACK报文，如果这个报文再网络中丢失了，这会导致发送方一直等待接收方的非0窗口通知，接收方也一直等待发送方的数据，如果不采取措施，会造成死锁的现象</li></ol> <p><strong>解决：</strong></p> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22799595/1644328911099-6c4ea409-653d-4716-9a4d-cfde74494431.png" alt="img"></p> <ol><li><p>TCP为每个连接设有一个持续定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续计时器</p></li> <li><p>如果持续计时器超时，就会发送窗口探测报文，而对方在确认这个探测报文时，给出自己的接收窗口大小</p></li> <li><ol><li>如果窗口依旧为0，那么收到这个报文的一方就重新启动持续计时器</li> <li>如果接收窗口不是0，那么死锁局面就打破</li></ol></li> <li><p>窗口探测次数一般为3次，如果3次后接收窗口还是0的话，有的TCP实现就会发RST报文来中断连接</p></li></ol> <h4 id="糊涂窗口"><a href="#糊涂窗口" class="header-anchor">#</a> 糊涂窗口</h4> <p>如果接收方太忙了，来不及取走接收窗口里面的数据，那么就会导致发送方的发送窗口越来越小。到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合征。</strong></p> <p>要知道，<code>TCP+IP</code>头有40个字节，为了传输那几个字节要搭上这么大的开销，不经济。</p> <p>所以糊涂窗口现象发生在发送方和接收方：</p> <ul><li>接收方可以通告一个小的窗口</li> <li>发送方可以发送小的数据</li></ul> <p>于是要解决糊涂窗口综合征，要解决上面两个问题</p> <ul><li>让接收方不通告小窗口给发送方</li> <li>让发送方避免发送小数据</li></ul> <p><strong>接收方策略：</strong></p> <p>当窗口大小小于<code>min(MSS,缓存大小的二分之一)</code>时，就会向发送方通告窗口为<code>0</code>，也就阻止了发送方再发数据过来。等接收方处理了一些数据后，窗口大小&gt;=MSS，或缓存空间一半时，就可以把窗口打开让发送方发送数据过来</p> <p><strong>发送方策略：</strong></p> <p>使用Nagle算法，算法思路是延时处理，它满足以下两个条件中的一条才可以发送数据</p> <ul><li>等到窗口大小&gt;=MSS或数据大小&gt;=MSS</li> <li>之前所有包的ACK都已收到</li></ul> <h3 id="拥塞控制"><a href="#拥塞控制" class="header-anchor">#</a> 拥塞控制</h3> <p>流量控制只是避免发送方的数据填满接收方的缓存，但是并不知道网络中到底发生了什么。</p> <p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等情况，这个时候TCP就会重传数据，一重传就会导致网络的负担更重。</p> <p>于是TCP不能忽略网上发生的事情，于是就有了**拥塞控制，**目的是避免发送方的数据填满整个网络</p> <h4 id="拥塞窗口"><a href="#拥塞窗口" class="header-anchor">#</a> 拥塞窗口</h4> <p>拥塞窗口cwnd是发送方维护的一个状态变量，它会根据网络的拥塞程度动态变化。</p> <p>发送窗口swnd=min(cwnd,rwnd)，也就是接收窗口和拥塞窗口的最小值</p> <h4 id="如何得知拥塞"><a href="#如何得知拥塞" class="header-anchor">#</a> 如何得知拥塞</h4> <p>其实只要发送方没有在规定时间内收到ACK应答报文，也就是发生了超时重传，就会认为网络中出现了拥塞。</p> <h4 id="慢启动"><a href="#慢启动" class="header-anchor">#</a> 慢启动</h4> <p>TCP在刚建立连接完成之后，首先有个慢启动过程。当发送方每收到一个ACK，拥塞窗口的大小就加一。</p> <p>例子：</p> <ul><li><p>连接建立完成之后，一开始初始化<code>cwnd=1</code>，表示可以传一个<code>MSS</code>大小的数据</p></li> <li><p>当收到一个ACK确认应答后，cwnd增加1，于是一次能够发送2个</p></li> <li><p>当收到两个ACK应答后，cwnd增加2，所以一次能发4个</p></li> <li><p>有一个慢启动门限<code>ssthresh</code>，当<code>cwnd&lt;ssthresh</code>时，慢启动依旧在继续</p></li> <li><p>当<code>cwnd&gt;=ssthresh</code>时，就会使用<strong>拥塞避免算法</strong></p></li></ul> <h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="header-anchor">#</a> 拥塞避免算法</h4> <p>当拥塞窗口超过慢启动门限时就会进入拥塞避免算法。</p> <p>那么进入拥塞避免算法后，它的规则是：<strong>每收到一个ACK，cwnd就增加1/cwnd</strong></p> <p>现假定<code>ssthresh</code>为8</p> <ul><li>当8个ACK应答确认到来时，每个确认增加1/8，8个ACK确认cwnd一共增加1，变成了线性增长</li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644332060160-c9ad7de4-a467-449d-a3cb-4aa26fdb3a68.webp" alt="img"></p> <p>像这样一直增长，网络就会进入拥塞状况了，于是就会出现丢包现象，这时就要对丢包的数据进行重传，当触发了重传机制，也就进入了<strong>拥塞发生算法</strong></p> <h4 id="拥塞发送"><a href="#拥塞发送" class="header-anchor">#</a> 拥塞发送</h4> <p>当网络中出现拥塞时，重传有两种机制：</p> <ul><li>超时重传</li> <li>快速重传</li></ul> <p><strong>当发生超时重传时的拥塞发生算法</strong></p> <p>这个时候，sshresh和cwnd的值都会发生变化：</p> <ul><li>sshresh设置为cwnd/2</li> <li>cwnd重置为1</li></ul> <p>接着就重新开始慢启动，慢启动是会突然减少数据流的，这种方式太激进了，反应也很强烈，会造成网络卡顿</p> <p><strong>当发生快速重传时的拥塞发生算法</strong></p> <ul><li><p>cwnd=cwnd/2</p></li> <li><p>ssthresh=cwnd</p></li> <li><p>进入<strong>快速恢复算法</strong></p></li></ul> <h4 id="快速恢复"><a href="#快速恢复" class="header-anchor">#</a> 快速恢复</h4> <p>快速重传和快速恢复一般同时使用，快速恢复算法认为，你还能收到三个重复的ACK说明网络也每那么糟糕。</p> <p>然后快速恢复算法如下：</p> <ul><li><p>拥塞窗口<code>cwnd=ssthresh+3</code></p></li> <li><p>重传丢失的数据包</p></li> <li><p>如果再收到重复的ACK，则cwnd增加1</p></li> <li><p>如果收到新数据的ACK后，把cwnd设置为第一步中的ssthresh值，原因是该ACK确认了数据，说明恢复过程结束，即再次进入拥塞避免状态</p></li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644333276617-0c228608-6d36-4ee5-a7fc-271ad585df10.webp" alt="img"></p> <h2 id="tcp快速打开原理-tfo"><a href="#tcp快速打开原理-tfo" class="header-anchor">#</a> TCP快速打开原理（TFO）</h2> <h3 id="tfo流程"><a href="#tfo流程" class="header-anchor">#</a> TFO流程</h3> <h4 id="首轮的三次握手"><a href="#首轮的三次握手" class="header-anchor">#</a> 首轮的三次握手</h4> <p>首先客户端发送SYN给服务端，服务端收到。但现在服务端不是立刻恢复<code>SYN+ACK</code>，而是计算得到一个<code>SYN Cookie</code>，将这个<code>Cookie</code>放到TCP报文的<code>Fast Open</code>选项中，然后才给客户端返回。</p> <p>客户端拿到这个Cookie值缓存下来，后面正常完成三次握手</p> <h4 id="后面的三次握手"><a href="#后面的三次握手" class="header-anchor">#</a> 后面的三次握手</h4> <p>后面的三次握手中，客户端会把之前缓存的<code>Cookie</code>、<code>SYN</code>发送给服务端，服务端验证了Cookie的合法性，如果不合法就直接丢弃，走正常的三次握手；如果合法就正常返回<code>SYN+ACK</code>，并且此时服务器能和客户端发送HTTP响应，也就是带上数据包</p> <h3 id="优势"><a href="#优势" class="header-anchor">#</a> 优势</h3> <p>TFO的优势在于后续的握手，在一个RTT时间就可以提前进行数据传输，积累起来还是一个比较大的优势</p> <h2 id="tcp拆包与ip分片"><a href="#tcp拆包与ip分片" class="header-anchor">#</a> TCP拆包与IP分片</h2> <h3 id="mtu-mss"><a href="#mtu-mss" class="header-anchor">#</a> MTU&amp;MSS</h3> <p><code>MTU</code>：一个网络包的最大长度，以太网中一般为1500字节</p> <p><code>MSS</code>：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大程度</p> <h3 id="ip分片"><a href="#ip分片" class="header-anchor">#</a> IP分片</h3> <ul><li>当数据大小超过MTU时，IP层就会对数据进行分片，分成一个个小于MTU的数据</li> <li>但是这样做有一个缺点，分成了多个片之后，一旦某个片丢失了，其他片都要丢失</li></ul> <h3 id="tcp拆包"><a href="#tcp拆包" class="header-anchor">#</a> TCP拆包</h3> <ul><li>在TCP中，有一个数据限制叫MSS，TCP一旦传输数据超过了这个限制，就要把消息分解成多个小于MSS的数据进行传输</li> <li>把完整的应用层数据分解成多个小于MSS的TCP数据包进行传输的过程叫做拆包</li></ul> <h4 id="拆包的好处"><a href="#拆包的好处" class="header-anchor">#</a> 拆包的好处</h4> <ul><li><p>如果不拆包，一个大TCP数据可能会在IP层被分片，分成多个IP数据报，一旦发生了丢失，就要重传全部分片，因为经过TCP会有重传，但是它重传的是一整个TCP，所以实际上就是重传全部分片</p></li> <li><p>如果拆包了，一个大TCP数据拆分成多个小TCP数据，这些小TCP数据不会造成IP分片，所以尽管某个IP数据报丢了，TCP也能只对丢失的那一块数据进行重传</p></li> <li><p>拆包提升了重传的效率，只需要重传丢失的那块就可以了，不需要全部重传</p></li></ul> <h2 id="tcp粘包、半包"><a href="#tcp粘包、半包" class="header-anchor">#</a> TCP粘包、半包</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22799595/1644414643491-7c276c26-33f0-477e-8ced-69ddfa6a20d1.png" alt="img"></p> <p><strong>半包</strong></p> <ul><li>接收方收到的TCP数据只是一部分而已，需要对数据进行拼接</li></ul> <p><strong>粘包</strong></p> <ul><li>TCP粘包是指应用层发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾</li></ul> <h3 id="粘包原因"><a href="#粘包原因" class="header-anchor">#</a> 粘包原因</h3> <h4 id="根本原因"><a href="#根本原因" class="header-anchor">#</a> 根本原因</h4> <p>应用层没有做好消息的边界处理</p> <h4 id="直接原因"><a href="#直接原因" class="header-anchor">#</a> 直接原因</h4> <ol><li><p>由于TCP连接复用造成的粘包问题，如果没有复用一个连接只提供端到端的两个进程使用，这时数据的传输方和发送方都是约定好了数据的格式的，但是多个进程使用一个TCP连接，此时多种不同结构的数据进到TCP的流式传输，边界分割肯定会出现问题</p></li> <li><p>使用Nagle算法，多个分组拼装为一个数据段发送出去，如果没有好的边界处理，在解包时可能发生粘包问题</p></li> <li><p>接收方来不及接收缓冲区的包，造成多个包接收</p></li></ol> <h4 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h4> <ol><li><p>关闭Nagle算法</p></li> <li><p>尾部标记序列，通过特殊符号标识数据包的边界</p></li> <li><p>头部标记，在TCP报文的头部加上数据长度，这样接收端在接收数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度</p></li> <li><p>发送方将每个数据包封装为固定长度，不够的可以用0来填充，这样接收方每次从接收缓冲区读取固定长度数据，就可以自然地把每个数据包拆分开</p></li></ol></div></article> <div class="main-div vssue"><!----></div></div></main> <aside class="aside" data-v-b3fda33c data-v-b3fda33c><div class="info-card main-div" data-v-1311ce9e data-v-b3fda33c><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/bg2.jpg);" data-v-1311ce9e><img src="/avatar-top.jpeg" alt="RunHio" class="info-avatar" data-v-1311ce9e></div> <div class="info-card-body" data-v-1311ce9e><section class="info-name" data-v-1311ce9e>
      RunHio
    </section> <section class="info-desc" data-v-1311ce9e>Record Growth</section> <section class="info-contact" data-v-1311ce9e><section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-location" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          Guangzhou, China
        </span></span></section> <!----> <section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-email" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          1056333479@qq.com
        </span></span></section></section></div> <div class="info-card-footer" data-v-1311ce9e><p class="footer-sns-link" data-v-1311ce9e><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-csdn" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-weibo" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-juejin" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-zhihu" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-github" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a></p></div></div> <div class="post-toc main-div aside-toc" style="position:relative;top:0;width:0px;" data-v-b3fda33c><h4>- CATALOG</h4> <div class="post-nav-toc"><ul><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#tcp如何实现可靠传输">TCP如何实现可靠传输</a><ul><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#重传机制">重传机制</a></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#滑动窗口">滑动窗口</a></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#流量控制">流量控制</a></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#拥塞控制">拥塞控制</a></li></ul></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#tcp快速打开原理-tfo">TCP快速打开原理（TFO）</a><ul><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#tfo流程">TFO流程</a></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#优势">优势</a></li></ul></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#tcp拆包与ip分片">TCP拆包与IP分片</a><ul><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#mtu-mss">MTU&amp;MSS</a></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#ip分片">IP分片</a></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#tcp拆包">TCP拆包</a></li></ul></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#tcp粘包、半包">TCP粘包、半包</a><ul><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#概念">概念</a></li><li><a href="/posts/2022/02/08/tcp-%E4%BA%8C.html#粘包原因">粘包原因</a></li></ul></li></ul></div></div></aside></div> <footer class="footer" data-v-7f2e4136><p class="footer-sns-link"><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-csdn"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-weibo"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-juejin"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-zhihu"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-github"></use></svg></span></a></p> <div class="copyright"><span id="custom">Copyright &copy; RunHio Blog 2021 <br /> </span> <!----></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.70cbfe2c.js" defer></script><script src="/assets/js/6.1419a14d.js" defer></script><script src="/assets/js/16.bfc00efe.js" defer></script>
  </body>
</html>