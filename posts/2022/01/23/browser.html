<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
    <title>Browser | RunHio 的博客 ｜ RunHio Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="个人博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.f77d8e52.css" as="style"><link rel="preload" href="/assets/js/app.70cbfe2c.js" as="script"><link rel="preload" href="/assets/js/6.1419a14d.js" as="script"><link rel="preload" href="/assets/js/25.c0a22e47.js" as="script"><link rel="prefetch" href="/assets/js/10.2e15052e.js"><link rel="prefetch" href="/assets/js/11.9760aa5a.js"><link rel="prefetch" href="/assets/js/12.5dd51cf0.js"><link rel="prefetch" href="/assets/js/13.9cea7209.js"><link rel="prefetch" href="/assets/js/14.a4892ffa.js"><link rel="prefetch" href="/assets/js/15.7e37fdbc.js"><link rel="prefetch" href="/assets/js/16.bfc00efe.js"><link rel="prefetch" href="/assets/js/17.42b751d4.js"><link rel="prefetch" href="/assets/js/18.7d94d9ca.js"><link rel="prefetch" href="/assets/js/19.5bf2dfa4.js"><link rel="prefetch" href="/assets/js/2.ffb60f29.js"><link rel="prefetch" href="/assets/js/20.76be16d6.js"><link rel="prefetch" href="/assets/js/21.d587942b.js"><link rel="prefetch" href="/assets/js/22.0c501fa3.js"><link rel="prefetch" href="/assets/js/23.23075f51.js"><link rel="prefetch" href="/assets/js/24.31b365c9.js"><link rel="prefetch" href="/assets/js/26.eb0b9821.js"><link rel="prefetch" href="/assets/js/27.902f48f0.js"><link rel="prefetch" href="/assets/js/28.792bd15b.js"><link rel="prefetch" href="/assets/js/29.1fa1e936.js"><link rel="prefetch" href="/assets/js/3.95e33632.js"><link rel="prefetch" href="/assets/js/30.6289061a.js"><link rel="prefetch" href="/assets/js/31.4caa844a.js"><link rel="prefetch" href="/assets/js/32.469025af.js"><link rel="prefetch" href="/assets/js/33.6c8ad3f6.js"><link rel="prefetch" href="/assets/js/34.a6b6bcf1.js"><link rel="prefetch" href="/assets/js/35.3975429e.js"><link rel="prefetch" href="/assets/js/36.87997eee.js"><link rel="prefetch" href="/assets/js/37.05db4cc6.js"><link rel="prefetch" href="/assets/js/38.8c5a7fbc.js"><link rel="prefetch" href="/assets/js/39.e0da8621.js"><link rel="prefetch" href="/assets/js/4.467972aa.js"><link rel="prefetch" href="/assets/js/40.647a3e55.js"><link rel="prefetch" href="/assets/js/41.98c93d10.js"><link rel="prefetch" href="/assets/js/5.963c915c.js"><link rel="prefetch" href="/assets/js/7.90b85d0e.js"><link rel="prefetch" href="/assets/js/8.2155397b.js"><link rel="prefetch" href="/assets/js/9.ac493e9a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f77d8e52.css">
    <meta id="referrer" name="referrer" content="never" />
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-7f2e4136><header class="header-container" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/post-bg.jpeg);" data-v-93921ff8 data-v-7f2e4136><nav class="navbar" style="position:absolute;opacity:1;transition:all 0.5s ease-in-out;" data-v-93921ff8><a href="/" class="navbar-link router-link-active">
    RunHio'Blog
  </a> <ul class="navbar-links"><li><a href="/" class="router-link-active">
        HOME
      </a></li><li><a href="/about/">
        ABOUT
      </a></li><li><a href="/tags/">
        TAGS
      </a></li></ul> <div id="nav-icon"><span></span><span></span><span></span></div></nav> <div class="header-title" data-v-93921ff8 data-v-93921ff8><h1 data-v-93921ff8>Browser</h1> <p data-v-93921ff8></p></div></header> <div class="container" data-v-b3fda33c data-v-7f2e4136><main class="main" style="width:60%;" data-v-b3fda33c><div class="post" data-v-b3fda33c data-v-b3fda33c><article class="main-div"><div class="post-content content content__default"><h1 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h1> <h2 id="显示相关"><a href="#显示相关" class="header-anchor">#</a> 显示相关</h2> <h3 id=""><a href="#" class="header-anchor">#</a></h3> <h3 id="白屏"><a href="#白屏" class="header-anchor">#</a> 白屏</h3> <p>目前大部分的前端框架都是JS驱动，所以在JS代码解析完成之前页面不会展示任何内容，也就是所谓的白屏。</p> <p>解决方法：</p> <ol><li><p>SSR</p></li> <li><p>预渲染</p></li> <li><p>骨架屏</p></li></ol> <h3 id="闪屏"><a href="#闪屏" class="header-anchor">#</a> 闪屏</h3> <p>先引入一个实际案例：</p> <p>如果现在需要一次性将大量数据插入到页面中：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
<span class="token comment">// 记录任务开始时间</span>
<span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 插入十万条数据</span>
<span class="token keyword">const</span> total <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>
<span class="token comment">// 获取容器</span>
<span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将数据插入容器中</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    li<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> total<span class="token punctuation">)</span>
    ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'JS运行时间：'</span><span class="token punctuation">,</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'总运行时间：'</span><span class="token punctuation">,</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment">// print: JS运行时间： 187</span>
<span class="token comment">// print: 总运行时间： 2844</span>
</code></pre></div><p>对十万条数据进行循环操作，JS的运行时间为187ms，但是最终渲染完成的总时间为2844ms</p> <ul><li><p>在JS的eventLoop中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染。</p></li> <li><p>第一个log的触发时间是在页面渲染前，此时得到的时间是JS运行所需要的时间</p></li> <li><p>第二个log的触发时间是在渲染完成，下一个eventloop中执行的</p></li></ul> <p>所以为了解决页面卡顿的问题，考虑采用渲染过程分批进行</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
<span class="token comment">//需要插入的容器</span>
<span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 插入十万条数据</span>
<span class="token keyword">let</span> total <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>
<span class="token comment">// 一次插入 20 条</span>
<span class="token keyword">let</span> once <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token comment">//总页数</span>
<span class="token keyword">let</span> page <span class="token operator">=</span> total<span class="token operator">/</span>once
<span class="token comment">//每条记录的索引</span>
<span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">//循环加载数据</span>
<span class="token keyword">function</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token parameter">curTotal<span class="token punctuation">,</span>curIndex</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>curTotal <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//每页多少条</span>
    <span class="token keyword">let</span> pageCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>curTotal <span class="token punctuation">,</span> once<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pageCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            li<span class="token punctuation">.</span>innerText <span class="token operator">=</span> curIndex <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">' : '</span> <span class="token operator">+</span> <span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> total<span class="token punctuation">)</span>
            ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">loop</span><span class="token punctuation">(</span>curTotal <span class="token operator">-</span> pageCount<span class="token punctuation">,</span>curIndex <span class="token operator">+</span> pageCount<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">loop</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们可以看到，页面加载的时间已经非常快了，每次刷新时可以很快的看到第一屏的所有数据，但是当我们快速滚动页面的时候，会发现页面出现闪屏或白屏的现象</p> <h4 id="为什么会出现闪屏现象"><a href="#为什么会出现闪屏现象" class="header-anchor">#</a> 为什么会出现闪屏现象</h4> <p>关于 FPS 和时间切片需要维持 16.7ms 的原因：</p> <ul><li><p>FPS 表示的是每秒钟画面更新次数，而所谓连续画面都是由一幅幅静止画面组成的，每幅画面称为一帧，FPS 是描述帧变化速度的物理量</p></li> <li><p>大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60 次，FPS 为 60frame/s，其设定受屏幕分辨率、屏幕尺寸和显卡的影响</p></li> <li><p>大多显示器也会以每秒 60 次的频率正在不断的更新屏幕上的图像，但由于人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了 16.7ms(1000/60≈16.7)，所以会让你误以为屏幕上的图像是静止不动的</p></li> <li><p>但刷新频率变成 1 次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状，大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升</p></li> <li><p>因此，最平滑动画的最佳循环间隔是 1000ms/60 即约等于 16.7ms</p></li></ul> <p>setTimeout 导致闪屏出现是因为 setTimeout 的执行步调和屏幕的刷新步调不一致，而导致后者的原因如下：</p> <ul><li>setTimeout 的执行时间并不是确定的：在 JS 中，setTimeout 任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此 setTimeout 的实际执行时间可能会比其设定的时间晚一些</li> <li>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而 setTimeout 只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同</li></ul> <p>在 setTimeout 中对 dom 进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象</p> <p>参考：https://juejin.cn/post/6844903938894872589</p> <h3 id="预渲染"><a href="#预渲染" class="header-anchor">#</a> 预渲染</h3> <p>所谓预渲染，就是在项目构建过程中，通过一些渲染机制将页面在构建的过程中就渲染好，然后插入到html中，这样在页面启动之前首先看到的就是预渲染的页面了。</p> <p>如使用<code>prerender-spa-plugin</code>，但是该方案最终也抛弃了，预渲染渲染的页面数据是在构建过程中就已经打包到了 html 中， 当真实访问页面的时候，真实数据可能已经和预渲染的数据有了很大的出入，而且预渲染的页面也是一个不可交互的页面，在页面没有启动之前，用户无法和预渲染的页面进行任何交互，预渲染页面中的数据反而会影响到用户获取真实的信息，当涉及到一些价格、金额、地理位置的地方甚至会导致用户做出一些错误的决定</p> <ul><li><p>动态数据无法展示，不同的用户看到的都是同样的页面</p></li> <li><p>路由很多时，代码构建时间太长</p></li> <li><p>用户容易误操作，由于预渲染时 js 还没有加载，因此展示出来的内容没有 js 的交互逻辑，比如按钮点击，在 js 加载完成之前用户点击是没有反应的</p></li> <li><p>预加载内容很少，当页面有内容是依赖动态数据加载时，在编译时是无法加载出动态数据的，因此会导致这部分内容编译不出来</p></li></ul> <p>预渲染比较适合静态或者变化不大的页面，能够通过部署前的一次静态渲染，将页面上大部分内容都渲染出来。这样搜索引擎在爬取的时候，就能够爬到相关的内容信息。</p> <h3 id="ssr"><a href="#ssr" class="header-anchor">#</a> SSR</h3> <p>暂留空</p> <h2 id="渲染流程"><a href="#渲染流程" class="header-anchor">#</a> 渲染流程</h2> <h3 id="构建dom树"><a href="#构建dom树" class="header-anchor">#</a> 构建DOM树</h3> <p>因为浏览器无法直接理解和使用HTML，所以要转为DOM树，浏览器才能使用。</p> <p>HTML解析：接收到HTML字节流时，首先要经过渲染引擎的HTML解析器，将HTML字节流转换为DOM树结构。</p> <p>流程：</p> <ul><li><p>将接收到的字节流根据文件的指定编码，转换为HTML元素</p></li> <li><p>分词器将转化后的数据转换成Token</p></li> <li><ul><li>Token的类别：Tag Token和文本Token</li></ul></li> <li><p>根据Token生成DOM树</p></li> <li><ul><li>HTML解析器在刚开始时，会默认创建一个根节点为document的空DOM结构，并将startTag docuemnt的Token压入栈中</li> <li>当遇到文本Token时，会向DOM结构中添加一个文本节点，但不会放入栈中</li></ul></li> <li><ul><li>当遇到一个startTag token，会创建一个对应的dom节点，插入DOM结构，并且将startTag token压入栈</li> <li>当遇到一个endTag token时，HTML解析器会查看栈顶的token是不是对应的startTag token，如果是则弹出，表示元素解析完毕</li></ul></li> <li><ul><li>直到最后document的endTag token出栈，整个文件解析完</li></ul></li></ul> <p>整个DOM树的构建过程其实就是： 字节 -&gt; 字符 -&gt; 令牌 -&gt; 节点对象 -&gt; 对象模型</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640865240279-5f3ce4a7-bd17-4ae2-8287-e077c07329fd.webp" alt="img"></p> <h3 id="脚本下载与执行"><a href="#脚本下载与执行" class="header-anchor">#</a> 脚本下载与执行</h3> <p>构建DOM过程中，如果遇到<code>&lt;script&gt;</code>标签，渲染引擎会停止对HTML的解析，而去加载执行JS代码，原因在于JS代码可能会改变DOM的结构。</p> <p>但是如果在<code>script</code>标签上添加了<code>async</code>或<code>defer</code>等属性，浏览器会异步加载和执行JS代码，而不会阻塞渲染。</p> <h3 id="样式计算"><a href="#样式计算" class="header-anchor">#</a> 样式计算</h3> <p>关于CSS样式，它的来源一般是三种：</p> <ul><li><p>link标签引用</p></li> <li><p>style标签中的样式</p></li> <li><p>元素的内嵌style属性</p></li></ul> <h4 id="格式化样式表"><a href="#格式化样式表" class="header-anchor">#</a> 格式化样式表</h4> <p>首先，浏览器是无法直接识别CSS样式文本的，因此渲染引擎接收到CSS文本之后就是将其转化为一个格式化的对象，即styleSheets</p> <h4 id="标准化样式属性"><a href="#标准化样式属性" class="header-anchor">#</a> 标准化样式属性</h4> <p>一些CSS样式不容易被渲染引擎所理解，因此需要在计算样式之前把它们标准化</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640866319026-a301578e-a96d-45c6-9ca0-5363193bb1fd.webp" alt="img"></p> <h4 id="计算每个节点的具体样式"><a href="#计算每个节点的具体样式" class="header-anchor">#</a> 计算每个节点的具体样式</h4> <p>样式被格式化和标准化之后，需要计算每个节点的具体样式信息。</p> <p>**继承：**每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采取浏览器默认的样式，也叫<code>UserAgent</code>样式</p> <p><strong>层叠</strong></p> <p>计算完成之后，所有的样式值会被挂载到<code>window.getComputedStyle</code>当中，也就可以通过JS来获取计算后的样式</p> <p>原本DOM和CSS的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSS也开始阻塞DOM的构建，只有CSS构建完毕后，DOM再恢复DOM构建。</p> <p>这是什么情况？</p> <p>这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSS。因为不完整的CSS是无法使用的，如果JavaScript想访问CSS并更改它，那么在执行JavaScript时，必须要能拿到完整的CSS。所以就导致了一个现象，如果浏览器尚未完成样式计算，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成样式计算。也就是说，<strong>在这种情况下，浏览器会先下载和构建CSS，然后再执行JavaScript，最后在继续构建DOM</strong>。</p> <h3 id="生成布局树"><a href="#生成布局树" class="header-anchor">#</a> 生成布局树</h3> <p>生成DOM树和DOM样式之后，接下来要做的就是通过浏览器的布局系统确定元素的位置，也就是要生成一个布局树</p> <p>流程：</p> <ul><li>遍历生成的DOM树节点，添加到布局树中</li> <li>计算布局树节点的坐标位置</li></ul> <p><strong>注：布局树仅包含可见元素，对于head标签和设置了display：none的元素将不会被放入其中。</strong></p> <p>网络上其他博客会说先生产Render Tree，也就是渲染树，其实这还是十几年前的事情了，现在Chrome团队做了大量重构，没有Render Tree的过程了，布局树的信息非常完善，具有了Render Tree的功能</p> <p>图示：</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640867459012-8f60e347-978e-416e-975e-265bf80826c2.webp" alt="img"></p> <h3 id="绘制"><a href="#绘制" class="header-anchor">#</a> 绘制</h3> <p>布局Layout之后，知道了不同元素的结构，样式，几何信息，我们要绘制一个页面需要知道每个元素的绘制先后顺序，主线程会遍历布局树，生产绘画记录paint records。</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640867935378-68a62aa8-e7a4-4374-bc72-c60f85bc988f.webp" alt="img"></p> <h3 id="合成composite"><a href="#合成composite" class="header-anchor">#</a> 合成Composite</h3> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640697864227-f33f7db8-0cae-4bf1-95b9-de7499bea648.webp" alt="img"></p> <p>在Paint阶段，会调用引擎的paint api进行像素级信息计算和绘制，像素级信息具体表现为帧信息（图层），浏览器会将各层的信息发送给GPU，GPU会将各层合成——composite，显示在屏幕上。</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/png/22799595/1640779612444-96cfa0d1-3280-473a-bbe4-84ea66199be5.png" alt="img"></p> <h4 id="layout-object"><a href="#layout-object" class="header-anchor">#</a> Layout Object</h4> <p>从浏览器的渲染过程中，可以看到HTML会被解析为DOM树，但是DOM树里面的DOM是提供给JS/HTML/CSS用的，并不能直接拿过来在页面或者位图里绘制。因此浏览器内部实现了<strong>Layout Object，旧版称之为Render Object</strong></p> <p><strong>每个Layout Object和DOM节点一一对应。Layout Object上实现了将其对应的DOM节点绘制进位图的方法，负责绘制这个DOM节点的可见内容如背景、边框等。Layout Object也是存放在一个树形结构中</strong>。</p> <p>虽然每个渲染对象实现了绘制每个DOM节点的方法，但并不是把这颗树进行简单遍历然后依次执行绘制方法就可以完成绘制，因为浏览器中还存在这重叠上下文，就是决定元素间相互覆盖（比如z-index）的东西。使得文档流中位置靠前位置的元素有可能覆盖靠后的元素。</p> <h4 id="paint-layer"><a href="#paint-layer" class="header-anchor">#</a> Paint Layer</h4> <p>旧版称之为<strong>RenderLayer。</strong></p> <p>处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的渲染对象将形成多个渲染层，以体现它们的层叠关系。</p> <p>所以，对于满足形成层叠上下文条件的渲染对象，浏览器会为其创建新的渲染层。能够导致浏览器为其创建新的渲染层的，包括以下几类常见的情况：</p> <ul><li><p>根元素 document</p></li> <li><p>有明确的定位属性（relative、fixed、sticky、absolute）</p></li> <li><p>opacity &lt; 1</p></li> <li><p>有 CSS fliter 属性</p></li> <li><p>有 CSS mask 属性</p></li> <li><p>有 CSS mix-blend-mode 属性且值不为 normal</p></li> <li><p>有 CSS transform 属性且值不为 none</p></li> <li><p>backface-visibility 属性为 hidden</p></li> <li><p>有 CSS reflection 属性</p></li> <li><p>有 CSS column-count 属性且值不为 auto或者有 CSS column-width 属性且值不为 auto</p></li> <li><p>当前有对于 opacity、transform、fliter、backdrop-filter 应用动画</p></li> <li><p>overflow 不为 visible</p></li></ul> <p>DOM 节点和渲染对象是一一对应的，满足以上条件的渲染对象就能拥有独立的渲染层。当然这里的独立是不完全准确的，并不代表着它们完全独享了渲染层，由于不满足上述条件的渲染对象将会与其第一个拥有渲染层的父元素共用同一个渲染层，因此实际上，这些渲染对象会与它的部分子元素共用这个渲染层。</p> <p><strong>Layer树决定了网页绘制的层次顺序，而从属于PaintLayer的LayerObject决定了这个Layer的内容，所以有的PaintLayer和LayerObject一起就决定了网页在屏幕上最终呈现出来的内容。</strong></p> <h4 id="compositing-layer"><a href="#compositing-layer" class="header-anchor">#</a> Compositing Layer</h4> <p>上述的过程可以搞定绘制，但是浏览器中经常有动画和3d的css等东西，这意味着页面在有这些元素时，页面显示会经常变动，也就意味着位图会经常变动，每次重绘整个绘图的开销是非常大的。</p> <p>因此浏览器为了优化这一过程，引出了Graphics Layer，也称为Compositing Layer，——合成层。</p> <p>某些具有CSS3的3D transform的元素、在opacity、transform属性上具有动画的元素、硬件加速的canvas和video等等，这些元素在上一步会提升为Paint Layer，而现在他们会提升为合成层。</p> <p>而其它没有被提升的每个Paint Layer都属于他祖先中最近的那个合成层。</p> <p>一个渲染层满足以下任一条件才会被提升为合成层：</p> <ul><li><p>3D transforms：translate3d、translateZ 等</p></li> <li><p>video、canvas、iframe 等元素</p></li> <li><p>通过 Element.animate() 实现的 opacity 动画转换</p></li> <li><p>通过 СSS 动画实现的 opacity 动画转换</p></li> <li><p>position: fixed</p></li> <li><p>具有 will-change 属性</p></li> <li><p>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition</p></li></ul> <h4 id="graphics-context"><a href="#graphics-context" class="header-anchor">#</a> Graphics Context</h4> <p>Graphics Context又称为图形上下文，它负责输出该层的位图，内存中的位图最终作为纹理上传到GPU，最后GPU将多层纹理进行合成，同时在纹理合成时对于每一层纹理都可以指定不同的合成参数，从而实现对纹理进行transform、mask、opacity等操作之后再合成。</p> <h4 id="隐式合成"><a href="#隐式合成" class="header-anchor">#</a> 隐式合成</h4> <p>满足某些显性的特殊条件时，渲染层会被浏览器提示为合成层。</p> <p>除此之外，浏览器在Composite阶段还存在一种隐式合成。</p> <p>例：</p> <p>两个absolute定位的div在屏幕上交叠，根据z-index的关系，其中一个div会覆盖在另一个div上。</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640778393886-4e49ca61-c664-4f1f-8199-754c9e682f7e.webp" alt="img"></p> <p>如果此时下方的div加上了css属性：<code>transform:translazeZ(0)</code>，就会被浏览器提升为合成层，提升后的合成层位于Document上，假如没有隐式合成，原本应该处于上方的div就依然还是跟Document共用一个GraphicsLayer，层级反而下降，出现了层叠关系错乱的问题。</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640778525105-58a41344-5f27-4605-855f-069f3c976ea7.webp" alt="img"></p> <p>所以为了纠正错误的层叠关系，浏览器让原本应该盖在上面的渲染层也同时提升为合成层。</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640778560034-a45e2e1b-f841-48f4-bb88-8f6700f3fe99.webp" alt="img"></p> <h4 id="层爆炸"><a href="#层爆炸" class="header-anchor">#</a> 层爆炸</h4> <p>在平时开发的过程中，我们很少去关注层合成的问题，很容易就产生一些不在预期范围内的合成层，当这些不符合预期的合成层达到一定数量级时，就会变成层爆炸。层爆炸会占用GPU和大量的内存资源，严重损耗页面性能，因此盲目使用GPU加速可能会适得其反。</p> <h4 id="层压缩"><a href="#层压缩" class="header-anchor">#</a> 层压缩</h4> <p>为了应对层爆炸的问题，浏览器也有对应策略。</p> <p>如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个Graphics Layer中。</p> <p>例：</p> <p>还是之前的模型，只不过这次不同的是，有四个 absolute 定位的 div 在屏幕内发生了交叠。此时处于最下方的 div 在加上了 CSS 属性 transform: translateZ(0) 后被浏览器提升为合成层，如果按照隐式合成的原理，盖在它上边的 div 会提升为一个新的合成层，第三个 div 又盖在了第二个上，自然也会被提升为合成层，第四个也同理。这样一来，岂不是就会产生四个合成层了</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640779129004-0506e089-eb07-46b6-b2d6-74258e34b5a4.webp" alt="img"></p> <p>然而浏览器会隐式地把多个渲染层压缩到同一个GraphicsLayer中进行，也就是说上方的三个div最终会处于同一个合成层中，这就是浏览器的层压缩。</p> <h4 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h4> <p>提升为合成层有以下几点好处：</p> <ul><li><p>合成层的位图，会交给GPU合成，比CPU快很多</p></li> <li><p>当需要repaint时，只需要repaint本身而不会影响到其他层</p></li> <li><p>对于transform和opacity，不会触发layout和paint</p></li></ul> <h4 id="建议"><a href="#建议" class="header-anchor">#</a> 建议</h4> <p><strong>提升动画效果的元素</strong></p> <p>合成层的好处是不会影响到其他元素的绘制，因此为了减少动画元素对其他元素的影响，从而减少paint，我们需要把动画提升为合成层。</p> <p>提升合成层最好的方式是使用css的will-change属性。</p> <p>will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>#target <span class="token punctuation">{</span>
  will<span class="token operator">-</span>change<span class="token operator">:</span> transform<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不兼容will-change的浏览器可以使用以下方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>#target <span class="token punctuation">{</span>
  transform<span class="token operator">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但需要注意的是，不要创建太多的渲染层。因为每创建一个渲染层就意味着新的内存分配和更复杂的层管理。</p> <p><strong>使用transform或者opacity来实现动画效果</strong></p> <p><img src="https://cdn.nlark.com/yuque/0/2021/png/22799595/1640780270558-5d8c397b-9557-43ab-be23-bf7b4c845e44.png" alt="img"></p> <p>从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，只需要做合成层合并即可。</p> <p>为了实现上述效果，就需要只使用那些仅触发Composite的属性。目前只有两个属性是满足该条件的：transform和opacity</p> <p><strong>减少绘制区域</strong></p> <p>对于不需要重新绘制的区域应该尽量避免绘制，以减少绘制区域，比如一个顶部固定不变的header，在页面内容某个区域repaint时，整个屏幕包括header也会被重绘。</p> <p>因此可以把header提升为合成层以减少该区域的绘制。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640867788562-606bb12e-b4ee-4736-b52c-d0b7dd0082fe.webp" alt="img"></p> <h3 id="回流-重绘"><a href="#回流-重绘" class="header-anchor">#</a> 回流 重绘</h3> <h4 id="回流"><a href="#回流" class="header-anchor">#</a> 回流</h4> <p>渲染对象在创建完成并添加到渲染树时，只是将DOM节点和它对应的样式结合起来，并不包含位置和大小信息。所以需要layout这一过程计算他们的大小和位置，这一过程称为回流</p> <h4 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h4> <p>通过构造渲染树和回流阶段，知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息（位置、大小），那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，整个过程叫重绘。</p> <p>在重绘阶段，系统会遍历渲染树，并调用渲染对象的paint方法。</p> <h4 id="何时发生"><a href="#何时发生" class="header-anchor">#</a> 何时发生</h4> <p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化时，就需要回流。比如：</p> <ul><li><p>添加或删除可见的DOM元素</p></li> <li><p>元素的位置发生变化</p></li> <li><p>元素的尺寸发生变化</p></li> <li><p>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片代替</p></li> <li><p>页面一开始渲染时</p></li> <li><p>浏览器窗口尺寸变化</p></li></ul> <p><strong>注：回流一定触发重绘，重绘不一定会回流</strong></p> <h4 id="浏览器的优化机制"><a href="#浏览器的优化机制" class="header-anchor">#</a> 浏览器的优化机制</h4> <p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化该过程。</p> <p>浏览器会将修改操作放入到队列里，直到过了一段时间或操作达到了一个阈值才清空队列。但是，**当访问布局信息进行操作时，会强制刷新队列，**比如：</p> <ul><li><p>offsetTop、offsetLeft、offsetWidth、offsetHeight</p></li> <li><p>scrollTop、scrollLeft、scrollWidth、scrollHeight</p></li> <li><p>clientTop、clientLeft、clientWidth、clientHeight</p></li> <li><p>getComputedStyle()</p></li> <li><p>getBoundingClientRect</p></li></ul> <p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。</p> <h4 id="如何减少回流重绘"><a href="#如何减少回流重绘" class="header-anchor">#</a> 如何减少回流重绘</h4> <p>如果我们不停地改变页面的布局，就会造成浏览器耗费大量的开销在进行页面的计算。</p> <p><strong>减少强制同步布局</strong></p> <p>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用就用一个变量缓存起来。</p> <p>比如以下属性和方法，浏览器会立刻清空队列</p> <p>读写offset家族，scroll家族，client家族属性，以及getComputedStyle方法和getBoundingClientRect方法</p> <p><strong>避免频繁操作DOM</strong></p> <p>可以创建一个documentFragment，DOM操作都在documentFragment上执行，最后把他挂载到父节点</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span>
  li<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'li'</span><span class="token operator">+</span>i
  content<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>
</code></pre></div><p>也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘</p> <p><strong>对于复杂的动画，使用绝对定位使其脱离文档流</strong></p> <p><strong>使用css3硬件加速</strong></p> <p><strong>避免使用table布局</strong></p> <p>因为 table 中某个元素旦触发了 reflow，那么整个 table 的元素都会触发 reflow。那么在不得已使用 table 的场合，可以设置 table-layout:auto;或者是 table-layout:fixed 这样可以让 table 一行一行的渲染，这种做法也是为了限制 reflow 的影响范围</p> <h3 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h3> <p>当我们输入一个页面地址时,发生了什么</p> <ol><li><p>浏览器先下载该地址所对应的html页面</p></li> <li><p>浏览器解析html页面的DOM结构</p></li> <li><p>开启下载线程对文档中的所有资源按优先级排序下载</p></li> <li><p>主线程继续解析文档,到达head节点,head里的外部资源无非是外链样式表和外链js</p></li></ol> <ul><li><ul><li>发现有外链css或外链js,如果是外链js则停止解析后续内容,等待该资源下载,下载完毕后立刻执行.</li> <li>如果是外链css,解析解析后续内容</li></ul></li></ul> <ol><li>解析到body</li></ol> <p>body里的情况比较多,body里可能只有dom元素,可能既有dom,也有css,js等资源,js资源又可能异步加载</p> <ul><li><p><strong>只有DOM元素</strong></p></li> <li><ul><li>这种情况比较简单,DOM树构建完,页面首次渲染</li></ul></li> <li><p><strong>只有DOM元素和外链js</strong></p></li> <li><ul><li>当解析到外链js的时候,该js尚未下载到本地,则js之前的DOM会被渲染到页面上,同时js会阻塞后面DOM的构建.所以在js执行完之前,我们在页面上看不到该js后面的DOM元素</li></ul></li> <li><p><strong>有DOM元素和外链css</strong></p></li> <li><ul><li>外链css不会影响css后面的DOM构建,但是会阻碍渲染,简单说,外链css加载完之前,页面还是白屏</li></ul></li> <li><p><strong>有DOM元素,外链js,外链css</strong></p></li> <li><ul><li>外链js和外链css的顺序会影响页面渲染.当body中js之前的外链css未加载完之前,页面不会被渲染</li> <li>当body中js之前的外链css加载完毕后,js之前的DOM树和css合并然后进行第一次渲染</li></ul></li></ul> <ol><li>文档解析完毕.当页面引用的所有JS<strong>同步代码</strong>执行完毕,触发<code>DOMContentLoaded</code>事件</li> <li>html文档中的图片资源,js代码中有异步加载的css js 图片资源都加载完毕之后,<code>load</code>事件触发</li></ol> <h4 id="head中资源的加载"><a href="#head中资源的加载" class="header-anchor">#</a> head中资源的加载</h4> <ul><li>head中js资源加载都会停止后面DOM的构建,但是不影响后面资源的下载</li> <li>css资源不会阻碍后面DOM的构建,但是会阻碍页面的首次渲染</li></ul> <h4 id="body中资源的加载"><a href="#body中资源的加载" class="header-anchor">#</a> body中资源的加载</h4> <ul><li>body中js资源加载都会停止后面DOM的构建,但是不影响后面资源的下载</li> <li>css资源不会阻碍后面DOM的构建,但是会阻碍页面的首次渲染</li></ul> <h4 id="domcontentloaded触发"><a href="#domcontentloaded触发" class="header-anchor">#</a> DomContentLoaded触发</h4> <p>DOMContentLoaded 事件在 <strong>html文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都执行完毕后触发</strong></p> <h4 id="load事件"><a href="#load事件" class="header-anchor">#</a> load事件</h4> <p>当页面 DOM 结构中的 js、css、图片，以及 js 异步加载的 js、css 、图片都加载完成之后，才会触发 load 事件。</p> <h4 id="async和defer的区别"><a href="#async和defer的区别" class="header-anchor">#</a> async和defer的区别</h4> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640870858366-b3aab931-0aa1-4724-b603-ffe9ea10cb9e.webp" alt="img"></p> <p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p> <p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件</p> <p>defer 与相比普通 script：</p> <p><strong>载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。</strong></p> <p><strong>在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。</strong></p> <h2 id="浏览器存储"><a href="#浏览器存储" class="header-anchor">#</a> 浏览器存储</h2> <h3 id="cookie"><a href="#cookie" class="header-anchor">#</a> Cookie</h3> <h4 id="来源"><a href="#来源" class="header-anchor">#</a> 来源</h4> <p>Cookie的本职工作并非是本地存储,而是&quot;维护状态&quot;.</p> <p>因为HTTP协议是无状态的,所以它不对请求和响应之间的通信状态进行保存,于是就诞生了Cookie.服务器可以设置或读取Cookie中包含的信息,借此维护用户跟服务器会话中的状态.</p> <p>可以把Cookie理解成一个存储在浏览器里的一个小文本文件,它附着在HTTP请求上,在浏览器和服务器之间飞来飞去,它可以携带用户信息,当服务器检查Cookie时,便可以获取客户端的状态.</p> <h4 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h4> <p>Cookie指某些网站为了辨别用户身份而存储在用户本地终端上的数据,Cookie是服务器生成,客户端进行维护和存储.</p> <p>通过Cookie,可以让服务器知道请求是来源哪个客户端,就可以进行客户端状态的维护.</p> <p>典型的应用场景有:</p> <ul><li><p>记住密码,下次自动登录</p></li> <li><p>购物车功能</p></li> <li><p>记录用户浏览数据,进行相关推荐</p></li></ul> <h4 id="原理和生成"><a href="#原理和生成" class="header-anchor">#</a> 原理和生成</h4> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640955184060-5dad113f-2943-43c4-a510-822c71befc40.webp" alt="img"></p> <p>第一次访问网站时,浏览器发出请求,服务器响应后会在响应头里添加一个Set-Cookie选项,将Cookie放入到响应请求中,在浏览器第二次发请求时,会通过Cookie请求头部将Cookie信息发送给服务器.</p> <p><strong>生成方式一:http response header中的set-cookie</strong></p> <p>我们可以通过响应头中的set-cookie指定要存储的cookie值,默认情况下,domain被设置为cookie页面的主机名,也可以手动设置domain的值</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Set<span class="token operator">-</span>Cookie<span class="token operator">:</span> id<span class="token operator">=</span>a3fWa<span class="token punctuation">;</span> Expires<span class="token operator">=</span>Wed<span class="token punctuation">,</span> <span class="token number">21</span> Oct <span class="token number">2018</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span><span class="token punctuation">;</span>
<span class="token comment">//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</span>
</code></pre></div><p>当Cookie的过期时间被设定时,设定的日期和时间只与客户端相关,而不是服务端</p> <p><strong>生成方式二:js中可以通过document.cookie进行读写cookie</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>document<span class="token punctuation">.</span>cookie<span class="token operator">=</span><span class="token string">&quot;userName=hello&quot;</span>
document<span class="token punctuation">.</span>cookie<span class="token operator">=</span><span class="token string">&quot;gender=male&quot;</span>
document<span class="token punctuation">.</span>cookie<span class="token operator">=</span><span class="token string">'age=20;domain=.baidu.com'</span>
</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640958104786-74a18559-f6fa-4f29-9c0b-9193802f5c6a.webp" alt="img"></p> <p><strong>Domain</strong>标识指定了哪些域名可以接受该Cookie,没有设置domain的会自动绑定到执行语句的当前域</p> <h4 id="缺陷"><a href="#缺陷" class="header-anchor">#</a> 缺陷</h4> <ul><li><p>Cookie不够大</p></li> <li><ul><li>Cookie的大小限制在4KB左右,对于复杂的存储需求是不够用的,当Cookie超过4KB时将被裁切.</li> <li>各浏览器的cookie每一个大小为4K,所以4KB并不是一个域名下所有cookie共享,而是一个name的大小</li></ul></li> <li><p>过多的Cookie带来性能浪费</p></li> <li><ul><li>同一个域名下的所有请求都会携带Cookie.对于静态文件的请求,携带cookie信息没有用,此时可以通过cdn的域名和主站的域名分开来解决</li></ul></li> <li><p>HTTP中Cookie是明文传输,安全性成问题</p></li></ul> <h4 id="安全"><a href="#安全" class="header-anchor">#</a> 安全</h4> <p><img src="https://cdn.nlark.com/yuque/0/2021/webp/22799595/1640958434210-aaff314c-8e10-42c5-877a-0e509e3b2b26.webp" alt="img"></p> <p>HttpOnly不支持读写,浏览器不允许脚本操作document.cookie去更改cookie,所以为了避免XSS攻击,通过JS的API无法访问带有HttpOnly标记的Cookie</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Set<span class="token operator">-</span>Cookie<span class="token operator">:</span> id<span class="token operator">=</span>a3fWa<span class="token punctuation">;</span> Expires<span class="token operator">=</span>Wed<span class="token punctuation">,</span> <span class="token number">21</span> Oct <span class="token number">2015</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span><span class="token punctuation">;</span> Secure<span class="token punctuation">;</span> HttpOnly
</code></pre></div><h3 id="localstorage"><a href="#localstorage" class="header-anchor">#</a> LocalStorage</h3> <h4 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h4> <ul><li><p>保存的数据长期存在,下一次访问该网站时,网页可以直接读取以前保存的数据</p></li> <li><p>大小为5M左右</p></li> <li><p>仅在客户端使用,不和服务端通信</p></li> <li><p>接口封装较好</p></li></ul> <h4 id="操作"><a href="#操作" class="header-anchor">#</a> 操作</h4> <p>localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。</p> <p>所有的数据都是以文本格式保存。</p> <p>存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。</p> <p><code>localStorage.setItem(&quot;key&quot;,&quot;value&quot;);</code></p> <p>读取数据使用getItem方法。它只有一个参数，就是键名。</p> <div class="language- extra-class"><pre class="language-text"><code>var valueLocal = localStorage.getItem(&quot;key&quot;);
</code></pre></div><h4 id="应用场景-2"><a href="#应用场景-2" class="header-anchor">#</a> 应用场景</h4> <p>用它可以来存储一些内容稳定的资源，如图片内容丰富的电商网站会用它来存储Base64格式的图片字符串</p> <h3 id="sessionstorage"><a href="#sessionstorage" class="header-anchor">#</a> SessionStorage</h3> <p>sessionStorage保存的数据用于浏览器的一次会话，窗口关闭时数据被清空。</p> <p><strong>即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口打开，那么sessionStorage无法共享。</strong></p> <p>localStorage和cookie在所有同源窗口中都是共享的</p> <h3 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h3> <ul><li>共同点：都保存在浏览器端，且都遵循同源策略</li> <li>不同点：生命周期和作用域不同</li></ul> <h2 id="安全-2"><a href="#安全-2" class="header-anchor">#</a> 安全</h2> <h3 id="xss"><a href="#xss" class="header-anchor">#</a> XSS</h3> <p>即跨站脚本攻击：在你的浏览器中插入一段恶意JavaScript脚本，因为浏览器无法区分脚本是被恶意注入的还是正常的内容，它都会执行，况且HTML非常灵活，可以在任何时候对它进行修改，窃取你的隐私信息和冒充你的身份进行操作</p> <p>用户是通过哪种方法“注入”恶意脚本的呢</p> <ul><li><p>来自用户的输入信息</p></li> <li><p>来自第三方链接</p></li> <li><p>URL参数</p></li> <li><p>POST参数</p></li> <li><p>Cookie(可能来自其他子域注入)</p></li></ul> <h4 id="分类"><a href="#分类" class="header-anchor">#</a> 分类</h4> <p><strong>存储型</strong></p> <p>攻击者事先将恶意代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能执行这段恶意的脚本。</p> <p>存储型XSS一般会出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或服务端的数据库中。</p> <p><strong>反射型</strong></p> <p>反射性XSS一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的URL，当受害者点击这些专门设计的链接时，恶意的代码会在受害者主机的浏览器上执行。</p> <p>对于访问者而言是一次性的，具体表现在我们把恶意脚本通过URL的方式传递给了服务器，而服务器不加处理地把脚本<strong>反射</strong>回访问者的浏览器，而使浏览器执行相应的脚本。</p> <p>要避免反射类型的XSS，必须需要后端的协调，后端解析前端数据时首先做相关字符串的检测和转义</p> <p>此类XSS通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端Cookies</p> <p>反射型和存储型的区别是：存储型XSS的恶意代码存在数据库中，反射型XSS的恶意代码存在URL中</p> <p>反射型XSS漏洞常见于通过URL传递参数的功能：如网站搜索、跳转等</p> <p>由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。</p> <p>POST的内容也可以触发反射型XSS，只不过触发条件苛刻，需要构造表单提交页面。</p> <p><strong>DOM型</strong></p> <p>DOM型XSS是基于DOM文档对象模型的,</p> <p>攻击者构造出特殊的URL,其中包含恶意的JS代码块,用户打开该URL后浏览器会进行解析,取出URL中的恶意代码进行执行.</p> <p>在此过程中代码会窃取用户数据并发送到攻击者的网站</p> <p>DOM型和前两种XSS的区别:DOM型XSS攻击中,取出和执行恶意代码由浏览器完成,属于前端JavaScript自身的安全漏洞,而其他两种XSS都属于服务端的安全漏洞.</p> <h4 id="预防xss"><a href="#预防xss" class="header-anchor">#</a> 预防XSS</h4> <p>XSS的攻击有两大要素:</p> <ul><li>攻击者提交恶意代码</li> <li>浏览器执行恶意代码</li></ul> <p><strong>输入过滤</strong></p> <p>如果由前端过滤输入，然后提交到后端的话。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。</p> <p>那么，如果后端在写入数据库前对输入进行过滤，然后就把“安全的”内容返回给前端。</p> <p>例如一个正常的用户输入了<code>5&lt;7</code>的内容，在写入数据库前被转义，变成了<code>5 &lt; 7</code>。</p> <p>但是，输入侧过滤虽然能够在某些情况下解决特定的XSS问题，但会引入很大的不确定性和乱码问题。</p> <p><strong>纯前端渲染</strong></p> <p>过程：</p> <ol><li><p>浏览器先加载一个静态HTML，此HTML中不包含任何跟业务相关的数据</p></li> <li><p>然后浏览器执行HTML中的JavaScript</p></li> <li><p>JavaScript通过Ajax加载业务数据，调用DOM API更新到页面上</p></li></ol> <p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p> <p><strong>预防DOM型XSS攻击</strong></p> <p>DOM型XSS攻击，实际上就是网站前端JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。</p> <p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code>时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code>等。</p> <p>DOM 中的内联事件监听器，如 <code>location、onclick、onerror、onload、onmouseover</code> 等，<code>a</code>标签的<code>href</code>属性，JavaScript 的<code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code>等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易 产生安全隐患，请务必避免。</p> <p><strong>拼接HTML时对其进行转义</strong></p> <h3 id="csrf"><a href="#csrf" class="header-anchor">#</a> CSRF</h3> <p>CSRF为跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获得的注册凭证，绕过后台的用户验证达到冒充用户，对攻击的网站执行某项操作的目的。</p> <p>流程：</p> <ul><li><p>受害者登录a.com，并保留了登录凭证（Cookie）。</p></li> <li><p>攻击者引诱受害者访问了b.com。</p></li> <li><p>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会携带Cookie</p></li> <li><p>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</p></li> <li><p>a.com以受害者的名义执行了act=xx。</p></li> <li><p>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</p></li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2022/webp/22799595/1641476282092-1b01d499-99b5-454c-b22c-ff96ef97a8b5.webp" alt="img"></p> <h4 id="csrf特点"><a href="#csrf特点" class="header-anchor">#</a> CSRF特点</h4> <ul><li><p>攻击者利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，而不是直接窃取数据</p></li> <li><p>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是冒用</p></li> <li><p>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</p></li></ul> <h4 id="预防csrf"><a href="#预防csrf" class="header-anchor">#</a> 预防CSRF</h4> <p>CSRF通常从第三方网站发起</p></div></article> <div class="main-div vssue"><!----></div></div></main> <aside class="aside" data-v-b3fda33c data-v-b3fda33c><div class="info-card main-div" data-v-1311ce9e data-v-b3fda33c><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/bg2.jpg);" data-v-1311ce9e><img src="/avatar-top.jpeg" alt="RunHio" class="info-avatar" data-v-1311ce9e></div> <div class="info-card-body" data-v-1311ce9e><section class="info-name" data-v-1311ce9e>
      RunHio
    </section> <section class="info-desc" data-v-1311ce9e>Record Growth</section> <section class="info-contact" data-v-1311ce9e><section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-location" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          Guangzhou, China
        </span></span></section> <!----> <section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-email" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          1056333479@qq.com
        </span></span></section></section></div> <div class="info-card-footer" data-v-1311ce9e><p class="footer-sns-link" data-v-1311ce9e><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-csdn" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-weibo" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-juejin" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-zhihu" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-github" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a></p></div></div> <div class="post-toc main-div aside-toc" style="position:relative;top:0;width:0px;" data-v-b3fda33c><h4>- CATALOG</h4> <div class="post-nav-toc"><ul><li><a href="/posts/2022/01/23/browser.html#显示相关">显示相关</a><ul><li><a href="/posts/2022/01/23/browser.html#"></a></li><li><a href="/posts/2022/01/23/browser.html#白屏">白屏</a></li><li><a href="/posts/2022/01/23/browser.html#闪屏">闪屏</a></li><li><a href="/posts/2022/01/23/browser.html#预渲染">预渲染</a></li><li><a href="/posts/2022/01/23/browser.html#ssr">SSR</a></li></ul></li><li><a href="/posts/2022/01/23/browser.html#渲染流程">渲染流程</a><ul><li><a href="/posts/2022/01/23/browser.html#构建dom树">构建DOM树</a></li><li><a href="/posts/2022/01/23/browser.html#脚本下载与执行">脚本下载与执行</a></li><li><a href="/posts/2022/01/23/browser.html#样式计算">样式计算</a></li><li><a href="/posts/2022/01/23/browser.html#生成布局树">生成布局树</a></li><li><a href="/posts/2022/01/23/browser.html#绘制">绘制</a></li><li><a href="/posts/2022/01/23/browser.html#合成composite">合成Composite</a></li><li><a href="/posts/2022/01/23/browser.html#总结">总结</a></li><li><a href="/posts/2022/01/23/browser.html#回流-重绘">回流 重绘</a></li><li><a href="/posts/2022/01/23/browser.html#补充">补充</a></li></ul></li><li><a href="/posts/2022/01/23/browser.html#浏览器存储">浏览器存储</a><ul><li><a href="/posts/2022/01/23/browser.html#cookie">Cookie</a></li><li><a href="/posts/2022/01/23/browser.html#localstorage">LocalStorage</a></li><li><a href="/posts/2022/01/23/browser.html#sessionstorage">SessionStorage</a></li><li><a href="/posts/2022/01/23/browser.html#区别">区别</a></li></ul></li><li><a href="/posts/2022/01/23/browser.html#安全-2">安全</a><ul><li><a href="/posts/2022/01/23/browser.html#xss">XSS</a></li><li><a href="/posts/2022/01/23/browser.html#csrf">CSRF</a></li></ul></li></ul></div></div></aside></div> <footer class="footer" data-v-7f2e4136><p class="footer-sns-link"><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-csdn"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-weibo"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-juejin"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-zhihu"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-github"></use></svg></span></a></p> <div class="copyright"><span id="custom">Copyright &copy; RunHio Blog 2021 <br /> </span> <!----></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.70cbfe2c.js" defer></script><script src="/assets/js/6.1419a14d.js" defer></script><script src="/assets/js/25.c0a22e47.js" defer></script>
  </body>
</html>