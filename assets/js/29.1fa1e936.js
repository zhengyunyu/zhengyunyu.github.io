(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{417:function(t,a,s){"use strict";s.r(a);var v=s(2),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[t._v("#")]),t._v(" 垃圾回收机制")]),t._v(" "),s("p",[t._v("GC即Garbage Collection，垃圾回收机制")]),t._v(" "),s("h2",{attrs:{id:"垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),s("p",[t._v("在js中创建的变量、对象、函数等都需要进行内存占用，js引擎会自动帮我进行分配。而当我们不再需要某个变量时，js引擎会帮我们自动进行回收。")]),t._v(" "),s("p",[t._v("例：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" test "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"isboyjc"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ntest "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("p",[t._v("在js中，引用类型是保存在堆内存中，在栈中只保存了一个地址。")]),t._v(" "),s("p",[t._v('上面的代码一开始引用了对象 {name: "isboyjc"} ，接着重新进行赋值，引用一个数组，那么之前引用的对象关系就没有了，如下图：')]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/22799595/1638272182901-fe923073-272a-4134-ae47-127ea26fc0f9.png",alt:"img"}})]),t._v(" "),s("p",[t._v("没有了引用关系则是无用对象，此时就需要被清理回收。")]),t._v(" "),s("h2",{attrs:{id:"垃圾回收策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收策略"}},[t._v("#")]),t._v(" 垃圾回收策略")]),t._v(" "),s("p",[t._v("在JavaScript内存管理中有一个概念叫可达性，即可用的值，反之不可用的值就需要回收。")]),t._v(" "),s("p",[t._v("JavaScript的回收机制就是"),s("strong",[t._v("定期")]),t._v("找出这些不可达的值，即不再需要的内存然后进行释放。")]),t._v(" "),s("p",[t._v("有两种常见的回收算法:")]),t._v(" "),s("ul",[s("li",[t._v("标记清除算法")]),t._v(" "),s("li",[t._v("引用计数算法")])]),t._v(" "),s("h3",{attrs:{id:"标记清除算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[t._v("#")]),t._v(" 标记清除算法")]),t._v(" "),s("p",[t._v("Mark-Sweep，标记清除是目前大多数浏览器的JavaScript引擎所使用的算法。")]),t._v(" "),s("p",[s("strong",[t._v("共分为标记阶段和清除阶段")])]),t._v(" "),s("ul",[s("li",[t._v("标记阶段即为所有活动对象做上标记")]),t._v(" "),s("li",[t._v("清除阶段则把没有标记的对象销毁")])]),t._v(" "),s("p",[t._v("引擎在执行GC时需要从出发点去遍历内存中的所有对象进行标记，而出发点有很多，我们称之为"),s("strong",[t._v("一组根对象")]),t._v("，比如全局的window对象、文档dom树等。")]),t._v(" "),s("p",[s("strong",[t._v("整个标记清除算法大致流程如下")]),t._v("：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有的对象都是垃圾，全部标记为0")])]),t._v(" "),s("li",[s("p",[t._v("然后就各个根对象开始遍历，把不是垃圾的节点标记为1")])]),t._v(" "),s("li",[s("p",[t._v("清理所有标记为0的垃圾，销毁并回收其占用的空间")])]),t._v(" "),s("li",[s("p",[t._v("最后把内存中的所有对象再标记为0，等待下一轮回收")])])]),t._v(" "),s("p",[s("strong",[t._v("缺点：")])]),t._v(" "),s("p",[t._v("在标记清除之后，剩余的对象内存位置是不变的，这会导致空间虽然被释放了，但是这些空间地址却不连续，出现了"),s("strong",[t._v("内存碎片")]),t._v("，会导致内存分配的问题。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/22799595/1638273613521-1c86eedb-1291-4edf-8773-e302bf4fb51c.png",alt:"img"}})]),t._v(" "),s("p",[t._v("假如此时新创建的对象需要分配大小为size的内存，由于内存空间是不连续的，所以需要遍历空闲的内存找到大于等于size的区域。")]),t._v(" "),s("p",[t._v("而找寻空闲内存也有对应策略：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("First-fit 找到大于等于size的块就立即返回")])]),t._v(" "),s("li",[s("p",[t._v("Best-fit 遍历整个空间列表，返回大于等于size的最小块")])]),t._v(" "),s("li",[s("p",[t._v("Worst-fit 遍历整个空间列表，将最大的分块切成两部分，一部分size大小并将其返回")])])]),t._v(" "),s("p",[t._v("Worst-fit会导致出现更多的小分块，不推荐使用；相比之下，First-fit的分配速度和效率是最合理的。")]),t._v(" "),s("p",[t._v("综上所述，标记清除算法的缺点:")]),t._v(" "),s("ul",[s("li",[t._v("内存碎片化")]),t._v(" "),s("li",[t._v("分配速度慢，即使使用First-fit，也需要O（n）的操作。")])]),t._v(" "),s("p",[s("strong",[t._v("标记整理算法：")])]),t._v(" "),s("p",[t._v("与标记清除算法一致，只是标记结束之后会将活着的对象向内存的一端移动，最后清掉边界的内存。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/22799595/1638274046198-6c299c00-7f5e-43dd-b489-c67474b9f812.png",alt:"img"}})]),t._v(" "),s("h3",{attrs:{id:"引用计数算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[t._v("#")]),t._v(" 引用计数算法")]),t._v(" "),s("p",[t._v("引用计数算法是早先的一种垃圾回收算法。")]),t._v(" "),s("p",[t._v("策略如下：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("声明了一个变量并且将一个引用类型赋值给该变量的时候，该值的引用次数就为1")])]),t._v(" "),s("li",[s("p",[t._v("如果同一个值又赋值给了另一个变量，引用次数就加一")])]),t._v(" "),s("li",[s("p",[t._v("如果该变量的值被其他值覆盖了，引用次数减一")])]),t._v(" "),s("li",[s("p",[t._v("当引用次数变成0时，垃圾回收器会对其进行回收")])])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此对象的引用计数为 1（a引用）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a \t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此对象的引用计数是 2（a,b引用）")]),t._v("\na "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("  \t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此对象的引用计数为 1（b引用）")]),t._v("\nb "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" \t \t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此对象的引用计数为 0（无引用）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// GC 回收此对象")]),t._v("\n")])])]),s("p",[t._v("但是另一种情况：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  \n  "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("此时对象A和B互相引用，他们的引用数量均为2，在test方法执行完成之后，会将A和B都赋值为null，即引用计数减一，但如果此时使用的是引用计数，则不会对AB进行清理，因为其引用计数依然不为零。")]),t._v(" "),s("p",[t._v("如果使用的是标记清除算法，执行完成之后，AB都不在作用域中，他们就会被当做是非活动对象来清除。")]),t._v(" "),s("p",[s("strong",[t._v("缺点：")])]),t._v(" "),s("p",[t._v("引用计数需要开辟一个新的计数器，同时无法解决循环引用导致的无法回收问题。")]),t._v(" "),s("h2",{attrs:{id:"v8对gc的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8对gc的优化"}},[t._v("#")]),t._v(" V8对GC的优化")]),t._v(" "),s("p",[t._v("现在大多数浏览器都是使用标记清除算法，v8也是，同时v8对垃圾回收机制也做了一定优化。")]),t._v(" "),s("h3",{attrs:{id:"分代式垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分代式垃圾回收"}},[t._v("#")]),t._v(" 分代式垃圾回收")]),t._v(" "),s("p",[t._v("V8将堆内存分为新生代和老生代两个区域，采用不同的垃圾回收器进行管理。")]),t._v(" "),s("p",[t._v("新时代的对象为存活时间比较短的对象，通常只支持1-8MB的容量；老生代为存活时间长或常驻内存的对象。")]),t._v(" "),s("p",[s("strong",[t._v("新生代回收")])]),t._v(" "),s("p",[t._v("新生代回收机制采用Cheney算法，将新生代区域划分了两个区域，一个为空闲区，一个为使用区。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/22799595/1638275357337-d45bf92e-58b7-40c3-a2eb-05a5b0ca03e7.png",alt:"img"}})]),t._v(" "),s("p",[t._v("新加入的对象会放进使用区中，当使用区快被写满时就会进行一次垃圾回收。")]),t._v(" "),s("p",[t._v("新生代垃圾回收器会对使用区中的对象进行标记，将标记的活动对象复制进空闲区，随后将非活动对象占用的空间清除掉。最后进行角色互换，把原来的使用区变为休闲区，休闲区变成使用区。")]),t._v(" "),s("p",[t._v("当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动进老生代中。")]),t._v(" "),s("p",[s("strong",[t._v("老生代回收")])]),t._v(" "),s("p",[t._v("老生代直接采用标记清除算法。")]),t._v(" "),s("p",[s("strong",[t._v("优点：")])]),t._v(" "),s("p",[t._v("分代式将一些新、小、存活时间短的对象作为新生代，进行频率较高的快速清理，而大、老、存活时间长的对象使其很少接受检查，该机制提高了垃圾回收机制的效率。")]),t._v(" "),s("h3",{attrs:{id:"并行回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并行回收"}},[t._v("#")]),t._v(" 并行回收")]),t._v(" "),s("p",[t._v("因为js是单线程语言，所以在主线程进行GC时会阻塞脚本的执行。")]),t._v(" "),s("p",[t._v("所谓并行，就是指垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同样执行回收工作。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/22799595/1638276957194-c5fce680-50fc-4026-9440-aa1f0fdf6fd7.png",alt:"img"}})]),t._v(" "),s("p",[t._v("新生代对象空间采取的就是并行策略，回收过程中启动多个线程来负责新生代中的垃圾清理操作。")]),t._v(" "),s("h3",{attrs:{id:"增量标记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#增量标记"}},[t._v("#")]),t._v(" 增量标记")]),t._v(" "),s("p",[t._v("虽然并行回收可以提高效率，但其依旧是一种全停顿的垃圾回收方式，对于老生代中较大的对象依旧需要耗费大量时间。")]),t._v(" "),s("p",[t._v("为了减少全停顿的时间，V8对老生代的标记进行优化，从全停顿标记切换为增量标记")]),t._v(" "),s("p",[t._v("增量标记就是将GC标记的过程分成了很多小步，每执行一小步就让应用逻辑执行一会，这样进行交替多次来完成一次GC标记。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/22799595/1638277475942-90812462-85d9-4230-ab79-35484b0a4f09.png",alt:"img"}})]),t._v(" "),s("p",[s("strong",[t._v("三色标记法（暂停与恢复）")])]),t._v(" "),s("p",[t._v("在没有使用增量标记前，我们单纯使用黑色和白色来进行数据标记，其标记流程即在执行一次完整的GC前，将所有对象标记为白色，然后从根对象出发遍历所有对象，将活动对象标记为黑色，最后再剩下的白色数据进行清除。")]),t._v(" "),s("p",[t._v("但是在进行增量标记时是需要应用逻辑与GC标记进行来回交替切换，黑白共存时我们无法判断这时GC标记是否完成。")]),t._v(" "),s("p",[t._v("所以引入三色标记法。在进行一次完整的GC前，将所有的对象标记为白色，然后就从所有根对象出发遍历，将根对象标记为灰色（当其至少还有一个引用没有被垃圾回收器扫描过），当该对象的所有引用被全部扫描过时，将其标记为黑色。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/22799595/1638277969883-20a897fc-1f73-490d-a292-b248bae47f23.png",alt:"img"}})]),t._v(" "),s("p",[t._v("采用三色标记法后我们恢复执行就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个的标记过程是否完成，如果没有灰色节点，直接进入清理阶段，如果还有灰色标记，恢复时直接从灰色的节点开始进行执行就好。")]),t._v(" "),s("p",[s("strong",[t._v("写屏障")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/22799595/1638278197447-43cea5b5-bb05-46be-94a3-ac38d49c1a49.png",alt:"img"}})]),t._v(" "),s("p",[t._v("假设在增量分段中ABC全部为活动对象，而后在应用程序中我们将B的指向改成了C，接着恢复增量标记。")]),t._v(" "),s("p",[t._v("此时C无引用关系，此轮不会进行对C的清理，但是这无关紧要，因为下一轮中会清理。")]),t._v(" "),s("p",[t._v("但是新的对象D，他初始色为白色，按照上面的增量标记过程，当无灰色对象时会对白色对象进行清理，新修改的D对象就会被清理，这肯定是不对的。")]),t._v(" "),s("p",[t._v("所以V8在增量回收中使用了写屏障机制，即一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改成灰色，保证GC的准确性。")]),t._v(" "),s("h3",{attrs:{id:"并发回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发回收"}},[t._v("#")]),t._v(" 并发回收")]),t._v(" "),s("p",[t._v("前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量（因为需要写屏障）两个缺点。")]),t._v(" "),s("p",[t._v("并发回收，它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/22799595/1638278645270-a29be4a0-329c-4786-801b-14709af167ae.png",alt:"img"}})]),t._v(" "),s("h3",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("V8的垃圾回收策略主要基于分代式垃圾回收机制。")]),t._v(" "),s("p",[t._v("新生代使用的是并行回收，老生代则是几种策略融合使用。")]),t._v(" "),s("p",[t._v("老生代主要采用并发标记，主线程在执行JavaScript时，辅助线程也同时执行标记操作（标记操作由辅助线程完成）")]),t._v(" "),s("p",[t._v("标记完成之后，再执行并行清理操作（主线程和多个辅助线程同时进行清理）")]),t._v(" "),s("p",[t._v("清理的任务会采用增量的方式在各个JavaScript任务之间完成、")])])}),[],!1,null,null,null);a.default=_.exports}}]);