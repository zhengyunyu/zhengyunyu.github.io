(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{405:function(v,_,t){"use strict";t.r(_);var a=t(2),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"tcp如何实现可靠传输"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp如何实现可靠传输"}},[v._v("#")]),v._v(" TCP如何实现可靠传输")]),v._v(" "),t("h3",{attrs:{id:"重传机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重传机制"}},[v._v("#")]),v._v(" 重传机制")]),v._v(" "),t("p",[v._v("TCP实现可靠传输的方式之一，是提供序列号与确认应答。")]),v._v(" "),t("p",[v._v("在TCP中，当发送端的数据到达接收主机时，接收端主机会返回应该确认应答消息，表示已收到消息。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644324667505-dc69a86b-ef68-44bf-803b-57f77a102040.webp",alt:"img"}})]),v._v(" "),t("h4",{attrs:{id:"超时重传"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#超时重传"}},[v._v("#")]),v._v(" 超时重传")]),v._v(" "),t("p",[v._v("重传机制的其中一个方式，就是在发送数据数据时，设定一个定时器，当超过指定的时间后，没有收到对方的"),t("code",[v._v("ACK")]),v._v("确认应答报文，就会重发该数据，也就是我们常说的"),t("strong",[v._v("超时重传")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("重传的原因有")]),v._v("：")]),v._v(" "),t("ul",[t("li",[v._v("数据丢失")]),v._v(" "),t("li",[v._v("应答ACK丢失")])]),v._v(" "),t("p",[v._v("TCP的超时重传策略是超时时间间隔加倍，当遇到一次重传的时候，超时时间就会加倍，当收到ACK时，则会重置超时时间")]),v._v(" "),t("h4",{attrs:{id:"快速重传"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速重传"}},[v._v("#")]),v._v(" 快速重传")]),v._v(" "),t("p",[v._v("快速重传的工作方式是当收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的报文段")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/22799595/1644325455963-14350f33-8a6f-431c-ae0f-d9b189b7fbe8.png",alt:"img"}})]),v._v(" "),t("h4",{attrs:{id:"sack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sack"}},[v._v("#")]),v._v(" SACK")]),v._v(" "),t("p",[v._v("快速重传只解决了一个问题，就是超时时间的问题，但是重传的时候，是重传之前的一个，还是重传之前的所有。")]),v._v(" "),t("p",[t("code",[v._v("SACK")]),v._v("叫选择性确定，这种方式需要在TCP头部的选项字段中加一个"),t("code",[v._v("SACK")]),v._v("，它"),t("strong",[v._v("可以将缓存的地图发送给发送方")]),v._v("，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以"),t("strong",[v._v("只重传丢失的数据")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644325606389-d7b20fb4-935c-4e85-9484-8e8b585be946.webp",alt:"img"}})]),v._v(" "),t("p",[v._v("如图，发送方收到了三次同样的ACK确认报文，于是就会触发快速重传机制，通过"),t("code",[v._v("SACK")]),v._v("信息发现只有"),t("code",[v._v("200-299")]),v._v("这段数据丢失，于是只重发这一段数据。")]),v._v(" "),t("p",[t("strong",[v._v("产生时机")])]),v._v(" "),t("ul",[t("li",[v._v("当接收方收到乱序的数据时就会回复SACK，正常顺序的就会回复ACK")])]),v._v(" "),t("h4",{attrs:{id:"d-sack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#d-sack"}},[v._v("#")]),v._v(" D-SACK")]),v._v(" "),t("p",[t("code",[v._v("D-SACK")]),v._v("是用来告诉发送方，有哪些数据被重复接收了。")]),v._v(" "),t("p",[t("strong",[v._v("例子：ACK丢失")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644325862323-16c8a1f3-5d78-4bb2-b5e9-129ba455a45c.webp",alt:"img"}})]),v._v(" "),t("ul",[t("li",[t("p",[v._v("接收方发给发送方的两个ACK确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000-3499）")])]),v._v(" "),t("li",[t("p",[v._v("于是接收方发现数据是重复收到的，回了一个"),t("code",[v._v("SACK=3000-3500")]),v._v("，告诉发送方3000-3500的数据已被接收")])]),v._v(" "),t("li",[t("p",[v._v("这样发送方就知道数据没有丢，是接收方的ACK丢了")])])]),v._v(" "),t("p",[t("strong",[v._v("例子：网络延时")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644326467718-96717887-cd61-4c6b-85a9-17d61da38faa.webp",alt:"img"}})]),v._v(" "),t("ul",[t("li",[t("p",[v._v("数据包（1000-1499）被网络延迟了，导致发送方没有收到ACK1500的确认报文")])]),v._v(" "),t("li",[t("p",[v._v("触发了快速重传机制后，被延迟的数据包（1000-1499）又到了接收方")])]),v._v(" "),t("li",[t("p",[v._v("所以接收方回了一个SACK=1000-1500，表示这是个重复的包")])]),v._v(" "),t("li",[t("p",[v._v("于是发送方就知道快速重传触发的原因不是发出去的包丢了，也不是回应的ACK丢了，而是因为网络延迟")])])]),v._v(" "),t("p",[v._v("所以，D-SACK的好处：")]),v._v(" "),t("ol",[t("li",[v._v("可以让发送方知道，是发出去的包丢了，还是接收方回应的ACK包丢了")]),v._v(" "),t("li",[v._v("可以知道是不是发送方的数据包被网络延迟了")])]),v._v(" "),t("h3",{attrs:{id:"滑动窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[v._v("#")]),v._v(" 滑动窗口")]),v._v(" "),t("p",[v._v("窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区保留自己已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。")]),v._v(" "),t("h4",{attrs:{id:"流水线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流水线"}},[v._v("#")]),v._v(" 流水线")]),v._v(" "),t("p",[t("strong",[v._v("发送方")])]),v._v(" "),t("ul",[t("li",[v._v("有一个窗口，TCP数据不是一个个发的，是每次发送多个")])]),v._v(" "),t("p",[t("strong",[v._v("接收方")])]),v._v(" "),t("ul",[t("li",[v._v("有一个窗口，数据不是一个个接收的，也可以接收很多个，可以接收乱序的数据")])]),v._v(" "),t("h4",{attrs:{id:"序号和确认号机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#序号和确认号机制"}},[v._v("#")]),v._v(" 序号和确认号机制")]),v._v(" "),t("p",[v._v("发送的数据是标上了序号的，而且发送方也是需要有接收方回复确认号来判断自己是否发送正常")]),v._v(" "),t("h4",{attrs:{id:"累计确认"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#累计确认"}},[v._v("#")]),v._v(" 累计确认")]),v._v(" "),t("p",[v._v("发送方不必一定要收到所有请求的ACK，收到某个ACK即可表明它前面的ACK都顺利到达发送方了")]),v._v(" "),t("h4",{attrs:{id:"窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#窗口"}},[v._v("#")]),v._v(" 窗口")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/22799595/1644327332986-04423ea5-3803-4fa7-ab43-2f7a3382fc67.png",alt:"img"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/22799595/1644327339197-75770de8-d653-42d7-a8aa-e2ee55f100fc.png",alt:"img"}})]),v._v(" "),t("h3",{attrs:{id:"流量控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[v._v("#")]),v._v(" 流量控制")]),v._v(" "),t("p",[v._v("发送方不能无脑地发数据给接收方，要考虑接收方处理能力。")]),v._v(" "),t("p",[v._v("如果一直无脑发数据给对方，但对方处理不过来，那么就会导致触发重发机制，对网络流量造成浪费。")]),v._v(" "),t("p",[v._v("所谓流量控制，就是TCP提供了一种机制可以让发送方根据接收方的实际接收能力，控制发送的数据量。")]),v._v(" "),t("h4",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[v._v("#")]),v._v(" 实现")]),v._v(" "),t("p",[v._v("利用TCP报文段中的首部字段——接收窗口来实现，这个接收窗口用于接收方发送给发送方，告诉发送方当前接收方还有多少可用的缓存空间")]),v._v(" "),t("h4",{attrs:{id:"窗口收缩过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#窗口收缩过程"}},[v._v("#")]),v._v(" 窗口收缩过程")]),v._v(" "),t("p",[v._v("TCP规定是不允许同时减少缓存同时收缩窗口的，或者先减少缓存再收缩窗口，")]),v._v(" "),t("h4",{attrs:{id:"死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[v._v("#")]),v._v(" 死锁")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/22799595/1644328789190-be690e78-7a64-42e4-82f1-7e55e8476ad3.png",alt:"img"}})]),v._v(" "),t("ol",[t("li",[v._v("当接收方通知发送方窗口为0后，发送方就不会继续发送数据了，当接收方处理好数据后，窗口增大了，会通知发送方窗口变大的消息")]),v._v(" "),t("li",[v._v("会向发送方通告一个窗口非0的ACK报文，如果这个报文再网络中丢失了，这会导致发送方一直等待接收方的非0窗口通知，接收方也一直等待发送方的数据，如果不采取措施，会造成死锁的现象")])]),v._v(" "),t("p",[t("strong",[v._v("解决：")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/22799595/1644328911099-6c4ea409-653d-4716-9a4d-cfde74494431.png",alt:"img"}})]),v._v(" "),t("ol",[t("li",[t("p",[v._v("TCP为每个连接设有一个持续定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续计时器")])]),v._v(" "),t("li",[t("p",[v._v("如果持续计时器超时，就会发送窗口探测报文，而对方在确认这个探测报文时，给出自己的接收窗口大小")])]),v._v(" "),t("li",[t("ol",[t("li",[v._v("如果窗口依旧为0，那么收到这个报文的一方就重新启动持续计时器")]),v._v(" "),t("li",[v._v("如果接收窗口不是0，那么死锁局面就打破")])])]),v._v(" "),t("li",[t("p",[v._v("窗口探测次数一般为3次，如果3次后接收窗口还是0的话，有的TCP实现就会发RST报文来中断连接")])])]),v._v(" "),t("h4",{attrs:{id:"糊涂窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#糊涂窗口"}},[v._v("#")]),v._v(" 糊涂窗口")]),v._v(" "),t("p",[v._v("如果接收方太忙了，来不及取走接收窗口里面的数据，那么就会导致发送方的发送窗口越来越小。到最后，"),t("strong",[v._v("如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合征。")])]),v._v(" "),t("p",[v._v("要知道，"),t("code",[v._v("TCP+IP")]),v._v("头有40个字节，为了传输那几个字节要搭上这么大的开销，不经济。")]),v._v(" "),t("p",[v._v("所以糊涂窗口现象发生在发送方和接收方：")]),v._v(" "),t("ul",[t("li",[v._v("接收方可以通告一个小的窗口")]),v._v(" "),t("li",[v._v("发送方可以发送小的数据")])]),v._v(" "),t("p",[v._v("于是要解决糊涂窗口综合征，要解决上面两个问题")]),v._v(" "),t("ul",[t("li",[v._v("让接收方不通告小窗口给发送方")]),v._v(" "),t("li",[v._v("让发送方避免发送小数据")])]),v._v(" "),t("p",[t("strong",[v._v("接收方策略：")])]),v._v(" "),t("p",[v._v("当窗口大小小于"),t("code",[v._v("min(MSS,缓存大小的二分之一)")]),v._v("时，就会向发送方通告窗口为"),t("code",[v._v("0")]),v._v("，也就阻止了发送方再发数据过来。等接收方处理了一些数据后，窗口大小>=MSS，或缓存空间一半时，就可以把窗口打开让发送方发送数据过来")]),v._v(" "),t("p",[t("strong",[v._v("发送方策略：")])]),v._v(" "),t("p",[v._v("使用Nagle算法，算法思路是延时处理，它满足以下两个条件中的一条才可以发送数据")]),v._v(" "),t("ul",[t("li",[v._v("等到窗口大小>=MSS或数据大小>=MSS")]),v._v(" "),t("li",[v._v("之前所有包的ACK都已收到")])]),v._v(" "),t("h3",{attrs:{id:"拥塞控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制"}},[v._v("#")]),v._v(" 拥塞控制")]),v._v(" "),t("p",[v._v("流量控制只是避免发送方的数据填满接收方的缓存，但是并不知道网络中到底发生了什么。")]),v._v(" "),t("p",[v._v("在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等情况，这个时候TCP就会重传数据，一重传就会导致网络的负担更重。")]),v._v(" "),t("p",[v._v("于是TCP不能忽略网上发生的事情，于是就有了**拥塞控制，**目的是避免发送方的数据填满整个网络")]),v._v(" "),t("h4",{attrs:{id:"拥塞窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞窗口"}},[v._v("#")]),v._v(" 拥塞窗口")]),v._v(" "),t("p",[v._v("拥塞窗口cwnd是发送方维护的一个状态变量，它会根据网络的拥塞程度动态变化。")]),v._v(" "),t("p",[v._v("发送窗口swnd=min(cwnd,rwnd)，也就是接收窗口和拥塞窗口的最小值")]),v._v(" "),t("h4",{attrs:{id:"如何得知拥塞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何得知拥塞"}},[v._v("#")]),v._v(" 如何得知拥塞")]),v._v(" "),t("p",[v._v("其实只要发送方没有在规定时间内收到ACK应答报文，也就是发生了超时重传，就会认为网络中出现了拥塞。")]),v._v(" "),t("h4",{attrs:{id:"慢启动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#慢启动"}},[v._v("#")]),v._v(" 慢启动")]),v._v(" "),t("p",[v._v("TCP在刚建立连接完成之后，首先有个慢启动过程。当发送方每收到一个ACK，拥塞窗口的大小就加一。")]),v._v(" "),t("p",[v._v("例子：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("连接建立完成之后，一开始初始化"),t("code",[v._v("cwnd=1")]),v._v("，表示可以传一个"),t("code",[v._v("MSS")]),v._v("大小的数据")])]),v._v(" "),t("li",[t("p",[v._v("当收到一个ACK确认应答后，cwnd增加1，于是一次能够发送2个")])]),v._v(" "),t("li",[t("p",[v._v("当收到两个ACK应答后，cwnd增加2，所以一次能发4个")])]),v._v(" "),t("li",[t("p",[v._v("有一个慢启动门限"),t("code",[v._v("ssthresh")]),v._v("，当"),t("code",[v._v("cwnd<ssthresh")]),v._v("时，慢启动依旧在继续")])]),v._v(" "),t("li",[t("p",[v._v("当"),t("code",[v._v("cwnd>=ssthresh")]),v._v("时，就会使用"),t("strong",[v._v("拥塞避免算法")])])])]),v._v(" "),t("h4",{attrs:{id:"拥塞避免算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞避免算法"}},[v._v("#")]),v._v(" 拥塞避免算法")]),v._v(" "),t("p",[v._v("当拥塞窗口超过慢启动门限时就会进入拥塞避免算法。")]),v._v(" "),t("p",[v._v("那么进入拥塞避免算法后，它的规则是："),t("strong",[v._v("每收到一个ACK，cwnd就增加1/cwnd")])]),v._v(" "),t("p",[v._v("现假定"),t("code",[v._v("ssthresh")]),v._v("为8")]),v._v(" "),t("ul",[t("li",[v._v("当8个ACK应答确认到来时，每个确认增加1/8，8个ACK确认cwnd一共增加1，变成了线性增长")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644332060160-c9ad7de4-a467-449d-a3cb-4aa26fdb3a68.webp",alt:"img"}})]),v._v(" "),t("p",[v._v("像这样一直增长，网络就会进入拥塞状况了，于是就会出现丢包现象，这时就要对丢包的数据进行重传，当触发了重传机制，也就进入了"),t("strong",[v._v("拥塞发生算法")])]),v._v(" "),t("h4",{attrs:{id:"拥塞发送"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞发送"}},[v._v("#")]),v._v(" 拥塞发送")]),v._v(" "),t("p",[v._v("当网络中出现拥塞时，重传有两种机制：")]),v._v(" "),t("ul",[t("li",[v._v("超时重传")]),v._v(" "),t("li",[v._v("快速重传")])]),v._v(" "),t("p",[t("strong",[v._v("当发生超时重传时的拥塞发生算法")])]),v._v(" "),t("p",[v._v("这个时候，sshresh和cwnd的值都会发生变化：")]),v._v(" "),t("ul",[t("li",[v._v("sshresh设置为cwnd/2")]),v._v(" "),t("li",[v._v("cwnd重置为1")])]),v._v(" "),t("p",[v._v("接着就重新开始慢启动，慢启动是会突然减少数据流的，这种方式太激进了，反应也很强烈，会造成网络卡顿")]),v._v(" "),t("p",[t("strong",[v._v("当发生快速重传时的拥塞发生算法")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("cwnd=cwnd/2")])]),v._v(" "),t("li",[t("p",[v._v("ssthresh=cwnd")])]),v._v(" "),t("li",[t("p",[v._v("进入"),t("strong",[v._v("快速恢复算法")])])])]),v._v(" "),t("h4",{attrs:{id:"快速恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速恢复"}},[v._v("#")]),v._v(" 快速恢复")]),v._v(" "),t("p",[v._v("快速重传和快速恢复一般同时使用，快速恢复算法认为，你还能收到三个重复的ACK说明网络也每那么糟糕。")]),v._v(" "),t("p",[v._v("然后快速恢复算法如下：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("拥塞窗口"),t("code",[v._v("cwnd=ssthresh+3")])])]),v._v(" "),t("li",[t("p",[v._v("重传丢失的数据包")])]),v._v(" "),t("li",[t("p",[v._v("如果再收到重复的ACK，则cwnd增加1")])]),v._v(" "),t("li",[t("p",[v._v("如果收到新数据的ACK后，把cwnd设置为第一步中的ssthresh值，原因是该ACK确认了数据，说明恢复过程结束，即再次进入拥塞避免状态")])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/22799595/1644333276617-0c228608-6d36-4ee5-a7fc-271ad585df10.webp",alt:"img"}})]),v._v(" "),t("h2",{attrs:{id:"tcp快速打开原理-tfo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp快速打开原理-tfo"}},[v._v("#")]),v._v(" TCP快速打开原理（TFO）")]),v._v(" "),t("h3",{attrs:{id:"tfo流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tfo流程"}},[v._v("#")]),v._v(" TFO流程")]),v._v(" "),t("h4",{attrs:{id:"首轮的三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#首轮的三次握手"}},[v._v("#")]),v._v(" 首轮的三次握手")]),v._v(" "),t("p",[v._v("首先客户端发送SYN给服务端，服务端收到。但现在服务端不是立刻恢复"),t("code",[v._v("SYN+ACK")]),v._v("，而是计算得到一个"),t("code",[v._v("SYN Cookie")]),v._v("，将这个"),t("code",[v._v("Cookie")]),v._v("放到TCP报文的"),t("code",[v._v("Fast Open")]),v._v("选项中，然后才给客户端返回。")]),v._v(" "),t("p",[v._v("客户端拿到这个Cookie值缓存下来，后面正常完成三次握手")]),v._v(" "),t("h4",{attrs:{id:"后面的三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后面的三次握手"}},[v._v("#")]),v._v(" 后面的三次握手")]),v._v(" "),t("p",[v._v("后面的三次握手中，客户端会把之前缓存的"),t("code",[v._v("Cookie")]),v._v("、"),t("code",[v._v("SYN")]),v._v("发送给服务端，服务端验证了Cookie的合法性，如果不合法就直接丢弃，走正常的三次握手；如果合法就正常返回"),t("code",[v._v("SYN+ACK")]),v._v("，并且此时服务器能和客户端发送HTTP响应，也就是带上数据包")]),v._v(" "),t("h3",{attrs:{id:"优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[v._v("#")]),v._v(" 优势")]),v._v(" "),t("p",[v._v("TFO的优势在于后续的握手，在一个RTT时间就可以提前进行数据传输，积累起来还是一个比较大的优势")]),v._v(" "),t("h2",{attrs:{id:"tcp拆包与ip分片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp拆包与ip分片"}},[v._v("#")]),v._v(" TCP拆包与IP分片")]),v._v(" "),t("h3",{attrs:{id:"mtu-mss"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mtu-mss"}},[v._v("#")]),v._v(" MTU&MSS")]),v._v(" "),t("p",[t("code",[v._v("MTU")]),v._v("：一个网络包的最大长度，以太网中一般为1500字节")]),v._v(" "),t("p",[t("code",[v._v("MSS")]),v._v("：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大程度")]),v._v(" "),t("h3",{attrs:{id:"ip分片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip分片"}},[v._v("#")]),v._v(" IP分片")]),v._v(" "),t("ul",[t("li",[v._v("当数据大小超过MTU时，IP层就会对数据进行分片，分成一个个小于MTU的数据")]),v._v(" "),t("li",[v._v("但是这样做有一个缺点，分成了多个片之后，一旦某个片丢失了，其他片都要丢失")])]),v._v(" "),t("h3",{attrs:{id:"tcp拆包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp拆包"}},[v._v("#")]),v._v(" TCP拆包")]),v._v(" "),t("ul",[t("li",[v._v("在TCP中，有一个数据限制叫MSS，TCP一旦传输数据超过了这个限制，就要把消息分解成多个小于MSS的数据进行传输")]),v._v(" "),t("li",[v._v("把完整的应用层数据分解成多个小于MSS的TCP数据包进行传输的过程叫做拆包")])]),v._v(" "),t("h4",{attrs:{id:"拆包的好处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拆包的好处"}},[v._v("#")]),v._v(" 拆包的好处")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("如果不拆包，一个大TCP数据可能会在IP层被分片，分成多个IP数据报，一旦发生了丢失，就要重传全部分片，因为经过TCP会有重传，但是它重传的是一整个TCP，所以实际上就是重传全部分片")])]),v._v(" "),t("li",[t("p",[v._v("如果拆包了，一个大TCP数据拆分成多个小TCP数据，这些小TCP数据不会造成IP分片，所以尽管某个IP数据报丢了，TCP也能只对丢失的那一块数据进行重传")])]),v._v(" "),t("li",[t("p",[v._v("拆包提升了重传的效率，只需要重传丢失的那块就可以了，不需要全部重传")])])]),v._v(" "),t("h2",{attrs:{id:"tcp粘包、半包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp粘包、半包"}},[v._v("#")]),v._v(" TCP粘包、半包")]),v._v(" "),t("h3",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/22799595/1644414643491-7c276c26-33f0-477e-8ced-69ddfa6a20d1.png",alt:"img"}})]),v._v(" "),t("p",[t("strong",[v._v("半包")])]),v._v(" "),t("ul",[t("li",[v._v("接收方收到的TCP数据只是一部分而已，需要对数据进行拼接")])]),v._v(" "),t("p",[t("strong",[v._v("粘包")])]),v._v(" "),t("ul",[t("li",[v._v("TCP粘包是指应用层发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾")])]),v._v(" "),t("h3",{attrs:{id:"粘包原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#粘包原因"}},[v._v("#")]),v._v(" 粘包原因")]),v._v(" "),t("h4",{attrs:{id:"根本原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#根本原因"}},[v._v("#")]),v._v(" 根本原因")]),v._v(" "),t("p",[v._v("应用层没有做好消息的边界处理")]),v._v(" "),t("h4",{attrs:{id:"直接原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接原因"}},[v._v("#")]),v._v(" 直接原因")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("由于TCP连接复用造成的粘包问题，如果没有复用一个连接只提供端到端的两个进程使用，这时数据的传输方和发送方都是约定好了数据的格式的，但是多个进程使用一个TCP连接，此时多种不同结构的数据进到TCP的流式传输，边界分割肯定会出现问题")])]),v._v(" "),t("li",[t("p",[v._v("使用Nagle算法，多个分组拼装为一个数据段发送出去，如果没有好的边界处理，在解包时可能发生粘包问题")])]),v._v(" "),t("li",[t("p",[v._v("接收方来不及接收缓冲区的包，造成多个包接收")])])]),v._v(" "),t("h4",{attrs:{id:"解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[v._v("#")]),v._v(" 解决方案")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("关闭Nagle算法")])]),v._v(" "),t("li",[t("p",[v._v("尾部标记序列，通过特殊符号标识数据包的边界")])]),v._v(" "),t("li",[t("p",[v._v("头部标记，在TCP报文的头部加上数据长度，这样接收端在接收数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度")])]),v._v(" "),t("li",[t("p",[v._v("发送方将每个数据包封装为固定长度，不够的可以用0来填充，这样接收方每次从接收缓冲区读取固定长度数据，就可以自然地把每个数据包拆分开")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);